/* Warning! This file is generated by the tinycsocket project. */
#ifndef TINYCSOCKET_HEADER_H_
#define TINYCSOCKET_HEADER_H_
/**********************************/
/********* tinycsocket.h **********/
/**********************************/
/*
 * Copyright 2018 Markus Lindelöw
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files(the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef TINYCSOCKET_INTERNAL_H_
#define TINYCSOCKET_INTERNAL_H_

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

static const char* const TCS_VERSION_TXT = "v0.3-dev";
static const char* const TCS_LICENSE_TXT =
    "Copyright 2018 Markus Lindelöw"
    "\n"
    "Permission is hereby granted, free of charge, to any person obtaining a copy"
    "of this software and associated documentation files(the \"Software\"), to deal"
    "in the Software without restriction, including without limitation the rights"
    "to use, copy, modify, merge, publish, distribute, sublicense, and / or sell"
    "copies of the Software, and to permit persons to whom the Software is"
    "furnished to do so, subject to the following conditions:"
    "\n"
    "The above copyright notice and this permission notice shall be included in all"
    "copies or substantial portions of the Software."
    "\n"
    "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR"
    "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,"
    "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE"
    "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER"
    "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,"
    "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE"
    "SOFTWARE.";

// First we have some code to recognize which system we are compiling against
#if defined(WIN32) || defined(__MINGW32__)
#define TINYCSOCKET_USE_WIN32_IMPL
#elif defined(__linux__) || defined(__sun) || defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || \
    (defined(__APPLE__) && defined(__MACH__)) || defined(__MSYS__) || defined(__unix__)
#define TINYCSOCKET_USE_POSIX_IMPL
#else
#pragma message("Warning: Unknown OS, trying POSIX")
#define TINYCSOCKET_USE_POSIX_IMPL
#endif

#ifdef __cplusplus
extern "C" {
#endif

// Then we have some platforms specific definitions
#if defined(TINYCSOCKET_USE_WIN32_IMPL)
#ifdef _WINSOCKAPI_
#error winsock.h included instead of winsock2.h. Define "_WINSOCKAPI_" or include this header file before windows.h to fix the problem
#endif
#ifndef __MINGW32__  // MinGW will generate a warning by it self.
#define _WINSOCKAPI_ // Prevent inclusion of winsock.h in windows.h, use winsock2.h
#endif
#include <basetsd.h>
typedef UINT_PTR TcsSocket;

#elif defined(TINYCSOCKET_USE_POSIX_IMPL)
typedef int TcsSocket;
#endif

/**
 * @brief Address Family
 */
typedef enum
{
    TCS_AF_ANY, /**< Layer 3 agnostic */
    TCS_AF_IP4, /**< INET IPv4 interface */
    TCS_AF_IP6, /**< INET IPv6 interface */
    TCS_AF_LENGTH
} TcsAddressFamily;

/**
 * @brief Network Address
 */
struct TcsAddress
{
    TcsAddressFamily family;
    union
    {
        struct
        {
            uint16_t port;    /**< Same byte order as the host */
            uint32_t address; /**< Same byte order as the host */
        } af_inet;
        struct
        {
            uint16_t port;
            uint32_t flowinfo;
            uint64_t address;
            uint32_t scope_id;
        } af_inet6;
    } data;
};

// gcc may trigger bug #53119
#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wmissing-braces"
#endif
static const struct TcsAddress TCS_ADDRESS_NULL = {TCS_AF_ANY, {0, 0}};
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif

extern const uint32_t TCS_ADDRESS_ANY_IP4;
extern const uint32_t TCS_ADDRESS_LOOPBACK_IP4;
extern const uint32_t TCS_ADDRESS_BROADCAST_IP4;
extern const uint32_t TCS_ADDRESS_NONE_IP4;

/**
 * @brief Network Interface Information
 */
struct TcsInterface
{
    struct TcsAddress address;
    char name[32];
};

extern const TcsSocket TCS_NULLSOCKET; /**< An empty socket, you should always define your new sockets to this value */
static const uint32_t TCS_NO_FLAGS = 0;

// Type
extern const int TCS_SOCK_STREAM; /**< Use for streaming types like TCP */
extern const int TCS_SOCK_DGRAM;  /**< Use for datagrams types like UDP */

// Protocol
extern const int TCS_IPPROTO_TCP; /**< Use TCP protocol (use with TCS_SOCK_STREAM for normal cases) */
extern const int TCS_IPPROTO_UDP; /**< Use UDP protocol (use with TCS_SOCK_DGRAM for normal cases) */

// Simple socket creation
typedef enum
{
    TCS_TYPE_TCP_IP4,
    TCS_TYPE_UDP_IP4,
    TCS_TYPE_TCP_IP6,
    TCS_TYPE_UDP_IP6,
} TcsType;

// Flags
extern const uint32_t TCS_AI_PASSIVE; /**< Use this flag for pure listening sockets */

// Recv flags
extern const uint32_t TCS_MSG_PEEK;
extern const uint32_t TCS_MSG_OOB;
extern const uint32_t TCS_MSG_WAITALL;

// Send flags
extern const uint32_t TCS_MSG_SENDALL;

// Backlog
extern const int TCS_BACKLOG_SOMAXCONN; /**< Max number of queued sockets when listening */

// Socket Direction
typedef enum
{
    TCS_SD_RECEIVE, /**< To shutdown incoming packets for socket */
    TCS_SD_SEND,    /**< To shutdown outgoing packets for socket */
    TCS_SD_BOTH,    /**< To shutdown both incoming and outgoing packets for socket */
} TcsSocketDirection;

// Option levels
extern const int TCS_SOL_SOCKET; /**< Socket option level for socket options */
extern const int TCS_SOL_IP;     /**< IP option level for socket options */

// Socket options
extern const int TCS_SO_BROADCAST;
extern const int TCS_SO_KEEPALIVE;
extern const int TCS_SO_LINGER;
extern const int TCS_SO_REUSEADDR; /**< This is a tricky one for crossplatform independency! */
extern const int TCS_SO_RCVBUF;    /**< Byte size of receiving buffer */
extern const int TCS_SO_RCVTIMEO;
extern const int TCS_SO_SNDBUF; /**< Byte size of receiving buffer */
extern const int TCS_SO_OOBINLINE;

// IP options
extern const int TCS_SO_IP_NODELAY;
extern const int TCS_SO_IP_MEMBERSHIP_ADD;
extern const int TCS_SO_IP_MEMBERSHIP_DROP;
extern const int TCS_SO_IP_MULTICAST_LOOP;

// Use for timeout to wait until infinity happens
extern const int TCS_INF;

// Return codes
typedef enum
{
    TCS_SUCCESS = 0,
    TCS_ERROR_UNKNOWN = -1,
    TCS_ERROR_MEMORY = -2,
    TCS_ERROR_INVALID_ARGUMENT = -3,
    TCS_ERROR_KERNEL = -4,
    TCS_ERROR_ADDRESS_LOOKUP_FAILED = -5,
    TCS_ERROR_CONNECTION_REFUSED = -6,
    TCS_ERROR_NOT_INITED = -7,
    TCS_ERROR_TIMED_OUT = -8,
    TCS_ERROR_NOT_IMPLEMENTED = -9,
    TCS_ERROR_NOT_CONNECTED = -10,
    TCS_ERROR_ILL_FORMED_MESSAGE = -11,
    TCS_ERROR_SOCKET_CLOSED = -12,
    TCS_ERROR_WOULD_BLOCK = -13,
} TcsReturnCode;

struct TcsPool;
struct TcsPollEvent
{
    TcsSocket socket;
    void* user_data;
    bool can_read;
    bool can_write;
    TcsReturnCode error;
};
static const struct TcsPollEvent TCS_NULLEVENT = {0, 0, false, false, TCS_SUCCESS};

/**
 * @brief Platform independent utility function to compose an IPv4 address from 4 bytes.
 * 
 * The order of the bytes are: a.b.c.d. Tinycsocket API will always expose host byte order (little endian).
 * You will _never_ need to think of byte order (except if you are debugging the library OS specific parts of course).
 *
 * @code
 * // Create address 192.168.0.1
 * uint32_t address = 0;
 * tcs_util_ipv4_args(192, 168, 0, 1, &address);
 * @endcode
 * 
 * @param a Is the first byte
 * @param b Is the second byte
 * @param c Is the third byte
 * @param d Is the forth byte
 * @param out_address is your ipv4 address stored as an unsigned 32bit integer. This parameter can not be NULL.
 * @return #TCS_SUCCESS if successful, otherwise the error code.
 */
TcsReturnCode tcs_util_ipv4_args(uint8_t a, uint8_t b, uint8_t c, uint8_t d, uint32_t* out_address);

/**
 * @brief Platform independent parsing of a string to an IPv4 address.
 *
 * If the local_port argument is excluded from the string the assign local_port value out the address will be zero.
 * Some example of valid formats are "192.168.0.1" or "127.0.0.1:1212".
 * The address format also supports mixed hex, octal and decimal format. For example "0xC0.0250.0.0x01:0x4bc".
 * 
 * @code
 * TcsSocket socket = TCS_NULLSOCKET;
 * tcs_create(&socket, TCS_TYPE_TCP_IP4);
 * struct TcsAddress address;
 * tcs_util_string_to_address("192.168.0.1:1212", &address);
 * tcs_connect_address(socket, address);
 * @endcode
 * 
 * @param str is a valid pointer to an IPv4 NULL terminated string address, with optional local_port number. Such as "192.168.0.1:1212".
 * @param out_address out pointer to save address.
 * @return #TCS_SUCCESS if successful, otherwise the error code.
 */
TcsReturnCode tcs_util_string_to_address(const char str[], struct TcsAddress* out_address);

/**
 * @brief Platform independent parsing of an IPv4 address to a string.
 *
 * @param address
 * @param out_str
 * @return #TCS_SUCCESS if successful, otherwise the error code.
 */
TcsReturnCode tcs_util_address_to_string(const struct TcsAddress* address, char out_str[40]);

/**
 * @brief Call this to initialize the library, eg. call this before any other function.
 *
 * You should call #tcs_lib_free() after you are done with the library (before program exit).
 * You need to call #tcs_lib_free the same amount of times as you call #tcs_lib_init().
 * 
 * @return #TCS_SUCCESS if successful, otherwise the error code.
 */
TcsReturnCode tcs_lib_init(void);

/**
 * @brief Call this when you are done with tinycsocket lib to free resources.
 *
 * You need to call this the same amount of times as you have called #tcs_lib_init().
 * This make it easy to use RAII of you use C++.
 * 
 * @return #TCS_SUCCESS if successful, otherwise the error code.
 */
TcsReturnCode tcs_lib_free(void);

/**
 * @brief Creates a new socket.
 *
 * @code
 * TcsSocket my_socket = TCS_NULLSOCKET;
 * tcs_create(&my_socket, TCS_TYPE_TCP_IP4);
 * @endcode
 *
 * @param socket_ctx is your in-out pointer to the socket context, you must initialize the socket to #TCS_NULLSOCKET before use.
 * @param socket_type specifies the internet and transport layer, for example #TCS_TYPE_TCP_IP4 or #TCS_TYPE_UDP_IP6.
 * @return #TCS_SUCCESS if successful, otherwise the error code.
 * @see tcs_destroy()
 * @see tcs_lib_init()
 */
TcsReturnCode tcs_create(TcsSocket* socket_ctx, TcsType socket_type);

/**
 * @brief Creates a new socket with BSD-style options such family, type and protocol.
 *
 * @code
 * TcsSocket my_socket = TCS_NULLSOCKET;
 * tcs_create_ext(&my_socket, TCS_AF_IP4, TCS_SOCK_STREAM, TCS_IPPROTO_TCP);
 * @endcode
 *
 * @param socket_ctx is your in-out pointer to the socket context, you must initialize the socket to #TCS_NULLSOCKET before use.
 * @param family only supports #TCS_AF_IP4 for now.
 * @param type specifies the type of the socket, for example #TCS_SOCK_STREAM or #TCS_SOCK_DGRAM.
 * @param protocol specifies the protocol, for example #TCS_IPPROTO_TCP or #TCS_IPPROTO_UDP.
 * @return #TCS_SUCCESS if successful, otherwise the error code.
 * @see tcs_destroy()
 * @see tcs_lib_init()
 */
TcsReturnCode tcs_create_ext(TcsSocket* socket_ctx, TcsAddressFamily family, int type, int protocol);

/**
 * @brief Binds a socket to local_port on all interfaces.
 *
 * This is similar to:
 * @code
 * struct TcsAddress local_address = {0};
 * local_address.family = TCS_AF_IP4;
 * local_address.data.af_inet.address = TCS_ADDRESS_ANY_IP4;
 * local_address.data.af_inet.local_port = local_port;
 * tcs_bind_address(socket_ctx, &local_address);
 * @endcode
 * 
 * @param socket_ctx is your in-out socket context you want bind.
 * @param local_port is your local portnumber you want to bind to.
 * @return #TCS_SUCCESS if successful, otherwise the error code.
 * @see tcs_bind_address()
 * @see tcs_listen()
 */
TcsReturnCode tcs_bind(TcsSocket socket_ctx, uint16_t local_port);

/**
 * @brief Binds a socket to a local address.
 *
 * @param socket_ctx is your in-out socket context you want to bind.
 * @param local_address is your local address you want to bind to.
 * @return #TCS_SUCCESS if successful, otherwise the error code.
 * @see tcs_bind()
 * @see tcs_get_interfaces()
 * @see tcs_listen()
 */
TcsReturnCode tcs_bind_address(TcsSocket socket_ctx, const struct TcsAddress* local_address);

/**
 * @brief Connect a socket to a remote hostname and port.
 *
 * @param socket_ctx is your in-out socket context you want to connect. 
 * @param hostname name of host or ip
 * @param port to connect to
 * @return #TCS_SUCCESS if successful, otherwise the error code.
 * @see tcs_bind()
 * @see tcs_get_interfaces()
 * @see tcs_listen()
 */
TcsReturnCode tcs_connect(TcsSocket socket_ctx, const char* hostname, uint16_t port);

/**
 * @brief Connects a socket to a remote address.
 *
 * @param socket_ctx is your in-out socket context.
 * @param address is the remote address to connect to.
 * @return #TCS_SUCCESS if successful, otherwise the error code.
 * @see tcs_shutdown()
 */
TcsReturnCode tcs_connect_address(TcsSocket socket_ctx, const struct TcsAddress* address);

/**
 * @brief Let a socket start listening for incoming connections.
 *
 * Call #tcs_bind() first to bind to a local address to listening at.
 *
 * @param socket_ctx is your in-out socket context.
 * @param backlog is the maximum number of queued incoming sockets. Use #TCS_BACKLOG_SOMAXCONN to set it to max.
 * @return #TCS_SUCCESS if successful, otherwise the error code.
 * @see tcs_accept()
 */
TcsReturnCode tcs_listen(TcsSocket socket_ctx, int backlog);

/**
* @brief Bind a socket to a local portnumber and start listening to new connections.
* 
* This is similar to:
* @code
* tcs_bind(socket_ctx, local_port);
* tcs_listen(socket_ctx, TCS_BACKLOG_SOMAXCONN);
* @endcode
*/
TcsReturnCode tcs_listen_to(TcsSocket socket_ctx, uint16_t local_port);

/**
 * @brief Accept a socket from a listening socket.
 *
 * The accepted socket will get assigned a random local free port.
 * The listening socket will not be affected by this call.
 * 
 * Example usage:
 * @code
 * TcsSocket listen_socket = TCS_NULLSOCKET;
 * tcs_create(&listen_socket, TCS_TYPE_TCP_IP4);
 * tcs_listen_to(listen_socket, 1212);
 * while (true)
 * {
 *   TcsSocket accept_socket = TCS_NULLSOCKET;
 *   tcs_accept(listen_socket, &accept_socket, NULL)
 *   // Do stuff with accept_socket here
 *   tcs_close(&accept_socket);
 * }
 * @endcode
 * 
 * @param socket_ctx is your listening socket you used when you called #tcs_listen_to().
 * @param child_socket_ctx is your accepted socket. Must have the in value of #TCS_NULLSOCKET.
 * @param address is an optional pointer to a buffer where the remote address of the accepted socket can be stored.
 * @return #TCS_SUCCESS if successful, otherwise the error code.
 */
TcsReturnCode tcs_accept(TcsSocket socket_ctx, TcsSocket* child_socket_ctx, struct TcsAddress* address);

/**
 * @brief Sends data on a socket, blocking
 *
 * @param socket_ctx is your in-out socket context.
 * @param buffer is a pointer to your data you want to send.
 * @param buffer_size is number of bytes of the data you want to send.
 * @param flags is currently not in use.
 * @param bytes_sent is how many bytes that was successfully sent.
 * @return #TCS_SUCCESS if successful, otherwise the error code.
 * @see tcs_receive()
 */
TcsReturnCode tcs_send(TcsSocket socket_ctx,
                       const uint8_t* buffer,
                       size_t buffer_size,
                       uint32_t flags,
                       size_t* bytes_sent);

/**
 * @brief Sends data to an address, useful with UDP sockets.
 *
 * @param socket_ctx is your in-out socket context.
 * @param buffer is a pointer to your data you want to send.
 * @param buffer_size is number of bytes of the data you want to send.
 * @param flags is currently not in use.
 * @param destination_address is the address to send to.
 * @param bytes_sent is how many bytes that was successfully sent.
 * @return #TCS_SUCCESS if successful, otherwise the error code.
 * @see tcs_receive_from()
 * @see tcs_getaddrinfo()
 */
TcsReturnCode tcs_send_to(TcsSocket socket_ctx,
                          const uint8_t* buffer,
                          size_t buffer_size,
                          uint32_t flags,
                          const struct TcsAddress* destination_address,
                          size_t* bytes_sent);

/**
* @brief Receive data from a socket to your buffer
*
* @param socket_ctx is your in-out socket context.
* @param buffer is a pointer to your buffer where you want to store the incoming data to.
* @param buffer_size is the byte size of your buffer, for preventing overflows.
* @param flags is currently not in use.
* @param bytes_received is how many bytes that was successfully written to your buffer.
* @return #TCS_SUCCESS if successful, otherwise the error code.
* @see tcs_send()
*/
TcsReturnCode tcs_receive(TcsSocket socket_ctx,
                          uint8_t* buffer,
                          size_t buffer_size,
                          uint32_t flags,
                          size_t* bytes_received);

/**
* @brief Receive data from an address, useful with UDP sockets.
*
* @param socket_ctx is your in-out socket context.
* @param buffer is a pointer to your buffer where you want to store the incoming data to.
* @param buffer_size is the byte size of your buffer, for preventing overflows.
* @param flags is currently not in use.
* @param source_address is the address to receive from.
* @param bytes_received is how many bytes that was successfully written to your buffer.
* @return #TCS_SUCCESS if successful, otherwise the error code.
* @see tcs_send_to()
* @see tcs_getaddrinfo()
*/
TcsReturnCode tcs_receive_from(TcsSocket socket_ctx,
                               uint8_t* buffer,
                               size_t buffer_size,
                               uint32_t flags,
                               struct TcsAddress* source_address,
                               size_t* bytes_received);

/**
* @brief Create a context used for waiting on several sockets.
*
* TcsPool can be used to monitor several sockets for events (reading, writing or error).
* Use tcs_pool_poll() to get a list of sockets ready to interact with.
*
* @code
* tcs_lib_init();
* TCS_SOCKET socket1 = TCS_NULLSOCKET;
* TCS_SOCKET socket2 = TCS_NULLSOCKET;
* tcs_create(&socket1, TCS_TYPE_UDP_IP4);
* tcs_create(&socket2, TCS_TYPE_UDP_IP4);
* tcs_bind(socket, 1000)
* tcs_bind(socket, 1001)
*
* struct TcsPool* pool = NULL;
* tcs_pool_create(&pool);
* tcs_pool_add(pool, socket1, NULL, true, false, false); // Only wait for incoming data
* tcs_pool_add(pool, socket2, NULL, true, false, false);
*
* size_t populated = 0;
* TcsPollEvent ev[2] = {TCS_NULLEVENT, TCS_NULLEVENT};
* tcs_pool_poll(pool, ev, 2, &populated, 1000);  // Will wait 1000 ms for data on port 1000 or 1001
* for (int i = 0; i < populated; ++i)
* {
*     if (ev[i].can_read)
*     {
*         uint8_t recv_buffer[8192] = {0};
*         size_t bytes_received = 0;
*         tcs_receive(ev[i].socket, recv_buffer, 8191, TCS_NO_FLAGS, &bytes_received);
*         recv_buffer[bytes_received] = '\n';
*         printf(recv_buffer);
*     }
* }
* tcs_pool_destory(&pool);
* tcs_destroy(&socket1);
* tcs_destroy(&socket2);
* tcs_lib_free();
* @endcode
*
* @param[out] pool is your out pool context pointer. Initiate a TcsPool pointer to NULL and use the address of this pointer.
* @return #TCS_SUCCESS if successful, otherwise the error code.
* @see tcs_pool_destory()
*/
TcsReturnCode tcs_pool_create(struct TcsPool** pool);

/**
* @brief Frees all resources bound to the pool.
*
* Will set @p pool to NULL when successfully.
*
* @param[in, out] pool is your in-out pool context pointer created with tcs_pool_create()
* @return #TCS_SUCCESS if successful, otherwise the error code.
* @see tcs_pool_create()
*/
TcsReturnCode tcs_pool_destory(struct TcsPool** pool);

/**
* @brief Add a socket to the pool.
*
* @param[in] pool is your in-out pool context pointer created with tcs_pool_create()
* @param socket_ctx will be added to the pool. Note that you can still use it outside of the pool.
* @param[in] user_data is a pointer of your choice that is associated with the socket. Use NULL if not used.
* @param poll_can_read true if you want to poll @p socket_ctx for to be able to read.
* @param poll_can_write true if you want to poll @p socket_ctx for to be able to write.
* @param poll_error true if you want to poll if any error has happened to @p socket_ctx.
* @return #TCS_SUCCESS if successful, otherwise the error code.
* @see tcs_pool_remove()
*/
TcsReturnCode tcs_pool_add(struct TcsPool* pool,
                           TcsSocket socket_ctx,
                           void* user_data,
                           bool poll_can_read,
                           bool poll_can_write,
                           bool poll_error);

/**
* @brief Remove a socket from the pool.
*
* @param[in] pool is a context pointer created with tcs_pool_create()
* @param socket_ctx will be removed from the pool.
* @return #TCS_SUCCESS if successful, otherwise the error code.
* @see tcs_pool_remove()
*/
TcsReturnCode tcs_pool_remove(struct TcsPool* pool, TcsSocket socket_ctx);

/**
* @brief Remove a socket from the pool.
*
* @param[in] pool is your in-out pool context pointer created with @p tcs_pool_create().
* @param[in, out] events is an array with in-out events. Assign each element to #TCS_NULLEVENT.
* @param events_count number of in elements in your events array. Does not make sense to have more events than number of sockets int the pool. If to short, all events may not be returned.
* @param[out] events_populated will contain the number of events the parameter ev has been populated with by the call.
* @param timeout_in_ms is the maximum wait time for any event. If any event happens before this time, the call will return immediately.
* @return #TCS_SUCCESS if successful, otherwise the error code.
* @see tcs_pool_remove()
*/
TcsReturnCode tcs_pool_poll(struct TcsPool* pool,
                            struct TcsPollEvent* events,
                            size_t events_count,
                            size_t* events_populated,
                            int64_t timeout_in_ms);

/**
* @brief Set parameters on a socket. It is recommended to use tcs_set_xxx instead.
*
* @param socket_ctx is your in-out socket context.
* @param level is the definition level.
* @param option_name is the option name.
* @param option_value is a pointer to the option value.
* @param option_size is the byte size of the data pointed by @p option_value.
* @return #TCS_SUCCESS if successful, otherwise the error code.
*/
TcsReturnCode tcs_set_option(TcsSocket socket_ctx,
                             int32_t level,
                             int32_t option_name,
                             const void* option_value,
                             size_t option_size);

/**
* @brief Get parameters on a socket. It is recommended to use tcs_get_xxx instead.
*
* @code
* uint8_t c;
* size_t a = sizeof(c);
* tcs_get_option(socket, TCS_SOL_IP, TCS_SO_IP_MULTICAST_LOOP, &c, &a);
* @endcode
*
* @param socket_ctx is your in-out socket context.
* @param level is the definition level.
* @param option_name is the option name.
* @param option_value is a pointer to the option value.
* @param option_size is a pointer the byte size of the data pointed by @p option_value.
* @return #TCS_SUCCESS if successful, otherwise the error code.
*/
TcsReturnCode tcs_get_option(TcsSocket socket_ctx,
                             int32_t level,
                             int32_t option_name,
                             void* option_value,
                             size_t* option_size);

/**
* @brief Turn off communication with a 3-way handshaking for the socket.
* 
* Use this function to cancel blocking calls (recv, accept etc) from another thread, or use sigaction.
* The socket will finish all queued sends first.
*
* @param socket_ctx is your in-out socket context.
* @param direction defines in which direction you want to turn off the communication.
* @return #TCS_SUCCESS if successful, otherwise the error code.
*/
TcsReturnCode tcs_shutdown(TcsSocket socket_ctx, TcsSocketDirection direction);

/**
* @brief Closes the socket, call this when you are done with the socket.
*
* @param socket_ctx is your in-out socket context.
* @return #TCS_SUCCESS if successful, otherwise the error code.
*/
TcsReturnCode tcs_destroy(TcsSocket* socket_ctx);

/**
* @brief Get addresses you can connect to given a computer name.
*
* @param hostname null terminated string
* @param address_family filters which address family you want, for example if you only are interested in IPv6. Use #TCS_AF_ANY to not filter.
* @param found_addresses is a pointer to your array which will be populated with found addresses.
* @param found_addresses_max_length is number of elements your @p found_addresses array can store.
* @param no_of_found_addresses will output the number of addresses that was populated in found_addresses.
* @return #TCS_SUCCESS if successful, otherwise the error code.
*/
TcsReturnCode tcs_resolve_hostname(const char* hostname,
                                   TcsAddressFamily address_family,
                                   struct TcsAddress found_addresses[],
                                   size_t found_addresses_max_length,
                                   size_t* no_of_found_addresses);

/**
* @brief Get local addresses of your computer.
*
* Use NULL for @p found_interfaces and 0 for @p found_interfaces_length to get the total number of addresses found.
*
* @param found_interfaces is a pointer to your array which will be populated with found interfaces.
* @param found_interfaces_length is number of elements your @p found_interfaces array can store.
* @param no_of_found_interfaces will output the number of addresses that was populated in found_interfaces.
* @return #TCS_SUCCESS if successful, otherwise the error code.
*/
TcsReturnCode tcs_local_interfaces(struct TcsInterface found_interfaces[],
                                   size_t found_interfaces_length,
                                   size_t* no_of_found_interfaces);

/*
* @brief Enable the socket to be allowed to use broadcast.
*
* Only valid for protocols that support broadcast, for example UDP. Default is false.
*
* @param socket_ctx socket to enable/disable permission to send broadcast on.
* @param do_allow_broadcast set to true to allow, false to forbid.
* @return #TCS_SUCCESS if successful, otherwise the error code.
*/
TcsReturnCode tcs_set_broadcast(TcsSocket socket_ctx, bool do_allow_broadcast);
TcsReturnCode tcs_get_broadcast(TcsSocket socket_ctx, bool* is_broadcast_allowed);

TcsReturnCode tcs_set_keep_alive(TcsSocket socket_ctx, bool do_keep_alive);
TcsReturnCode tcs_get_keep_alive(TcsSocket socket_ctx, bool* is_keep_alive_enabled);

TcsReturnCode tcs_set_reuse_address(TcsSocket socket_ctx, bool do_allow_reuse_address);
TcsReturnCode tcs_get_reuse_address(TcsSocket socket_ctx, bool* is_reuse_address_allowed);

TcsReturnCode tcs_set_send_buffer_size(TcsSocket socket_ctx, size_t send_buffer_size);
TcsReturnCode tcs_get_send_buffer_size(TcsSocket socket_ctx, size_t* send_buffer_size);

TcsReturnCode tcs_set_receive_buffer_size(TcsSocket socket_ctx, size_t receive_buffer_size);
TcsReturnCode tcs_get_receive_buffer_size(TcsSocket socket_ctx, size_t* receive_buffer_size);

TcsReturnCode tcs_set_receive_timeout(TcsSocket socket_ctx, int timeout_ms);
TcsReturnCode tcs_get_receive_timeout(TcsSocket socket_ctx, int* timeout_ms);

TcsReturnCode tcs_set_linger(TcsSocket socket_ctx, bool do_linger, int timeout_seconds);
TcsReturnCode tcs_get_linger(TcsSocket socket_ctx, bool* do_linger, int* timeout_seconds);

TcsReturnCode tcs_set_ip_no_delay(TcsSocket socket_ctx, bool use_no_delay);
TcsReturnCode tcs_get_ip_no_delay(TcsSocket socket_ctx, bool* is_no_delay_used);

TcsReturnCode tcs_set_out_of_band_inline(TcsSocket socket_ctx, bool enable_oob);
TcsReturnCode tcs_get_out_of_band_inline(TcsSocket socket_ctx, bool* is_oob_enabled);

TcsReturnCode tcs_set_ip_multicast_add(TcsSocket socket_ctx,
                                       const struct TcsAddress* local_address,
                                       const struct TcsAddress* multicast_address);

// Use NULL for local_Address for default (make sense? or should we "#define DEFAULT NULL" ?
TcsReturnCode tcs_set_ip_multicast_drop(TcsSocket socket_ctx,
                                        const struct TcsAddress* local_address,
                                        const struct TcsAddress* multicast_address);

TcsReturnCode tcs_receive_netstring(TcsSocket socket_ctx, uint8_t* buffer, size_t buffer_size, size_t* bytes_received);

TcsReturnCode tcs_send_netstring(TcsSocket socket_ctx, const uint8_t* buffer, size_t buffer_size);

#ifdef __cplusplus
}
#endif

#endif

#ifdef TINYCSOCKET_IMPLEMENTATION
/**********************************/
/****** tinydatastructures.h ******/
/**********************************/
#ifndef TINYDATASTRUCTURES_H_
#define TINYDATASTRUCTURES_H_

#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// Goals:
// Threadsafe
// Secure, no data leaks
// Tiny compile times
// Tiny generated file size (light on instruction cache)
// Optimized for "is there one, there might be many"
// Tiny code pollution
// Easy to debug

static inline int ulist_create(void** data, size_t init_capacity, size_t* capacity, size_t element_size);
static inline int ulist_reserve(void** data, size_t requested_capacity, size_t* capacity, size_t element_size);
static inline int ulist_create_copy(void* from_data,
                                    size_t from_count,
                                    void** to_data,
                                    size_t* to_count,
                                    size_t* to_capacity,
                                    size_t element_size);
static inline int ulist_destroy(void** data);
static inline size_t ulist_best_capacity_fit(size_t n);
static inline int ulist_reserve(void** data, size_t requested_capacity, size_t* capacity, size_t element_size);
static inline int ulist_resize(void** data, size_t new_size, size_t* capacity, size_t* count, size_t element_size);
static inline int ulist_add(void** data,
                            void* add_data,
                            size_t add_count,
                            size_t* count,
                            size_t* capacity,
                            size_t element_size);
static inline int ulist_remove(void* data, size_t index, size_t remove_count, size_t* count, size_t element_size);
static inline int ulist_relax(void** data, size_t count, size_t* capacity);
static inline int ulist_pop(void* data, size_t* count, void* out_element, size_t element_size);

static inline int ulist_create(void** data, size_t init_capacity, size_t* capacity, size_t element_size)
{
    return ulist_reserve(data, init_capacity, capacity, element_size);
}

static inline int ulist_create_copy(void* from_data,
                                    size_t from_count,
                                    void** to_data,
                                    size_t* to_count,
                                    size_t* to_capacity,
                                    size_t element_size)
{
    int sts = ulist_create(to_data, from_count, to_capacity, element_size);
    if (sts != 0)
        return sts;
    memcpy(from_data, *to_data, from_count * element_size);
    *to_count = from_count;
    return 0;
}

static inline int ulist_destroy(void** data)
{
    if (*data != NULL)
    {
        free(*data);
        *data = NULL;
    }
    return 0;
}

static inline size_t ulist_best_capacity_fit(size_t n)
{
    size_t best_fit = 8;
    size_t size_list[] = {
        8, 32, 128, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576};
    if (n >= size_list[14])
    {
        best_fit = ((n + size_list[14] - 1) / size_list[14]) * size_list[14];
    }
    else
    {
        for (size_t i = 0; i < 15; ++i)
        {
            if (n <= size_list[i])
            {
                best_fit = size_list[i];
                break;
            }
        }
    }
    return best_fit;
}

static inline int ulist_reserve(void** data, size_t requested_capacity, size_t* capacity, size_t element_size)
{
    if (requested_capacity <= *capacity)
        return 0;

    size_t new_capacity = ulist_best_capacity_fit(requested_capacity);

    void* new_data = realloc(*data, new_capacity * element_size);
    if (new_data == NULL)
        return -1;
    memset((uint8_t*)new_data + *capacity * element_size, 0, (new_capacity - *capacity) * element_size);
    *data = new_data;
    *capacity = new_capacity;
    return 0;
}

static inline int ulist_resize(void** data, size_t new_size, size_t* capacity, size_t* count, size_t element_size)
{
    ulist_reserve(data, new_size, capacity, element_size);
    if (new_size < *count)
        memset((uint8_t*)*data + new_size * element_size, 0, *count - new_size);
    *count = new_size;
    return 0;
}

static inline int ulist_add(void** data,
                            void* add_data,
                            size_t add_count,
                            size_t* count,
                            size_t* capacity,
                            size_t element_size)
{
    ulist_reserve(data, add_count * element_size, capacity, element_size);
    memcpy((uint8_t*)*data + *count * element_size, add_data, add_count * element_size);
    *count += add_count;
    return 0;
}

static inline int ulist_remove(void* data, size_t index, size_t remove_count, size_t* count, size_t element_size)
{
    if (index + remove_count > *count)
        return -1;
    void* dst = (uint8_t*)data + index * element_size;
    void* src = (uint8_t*)data + (*count - 1) * element_size * remove_count;
    memmove(dst, src, element_size * remove_count);
    *count -= remove_count;
    return 0;
}

static inline int ulist_relax(void** data, size_t count, size_t* capacity)
{
    size_t suggested_capacity = ulist_best_capacity_fit(count);
    if (suggested_capacity < *capacity)
    {
        void* new_data = realloc(*data, suggested_capacity);
        if (new_data == NULL)
            return -1;
        *data = new_data;
        *capacity = suggested_capacity;
    }
    return 0;
}

static inline int ulist_pop(void* data, size_t* count, void* out_element, size_t element_size)
{
    if (*count < 1)
        return -1;
    if (out_element != NULL)
        memmove(out_element, (uint8_t*)data + *count * element_size, element_size); // allow to pop to another element
    memset((uint8_t*)data + *count * element_size, 0, element_size);
    (*count)--;
    return 0;
}

#define TDS_ULIST_IMPL(TYPE, NAME)                                                                          \
                                                                                                            \
    typedef struct                                                                                          \
    {                                                                                                       \
        TYPE* data;                                                                                         \
        size_t count;                                                                                       \
        size_t capacity;                                                                                    \
    } UList_##NAME;                                                                                         \
                                                                                                            \
    static inline int ulist_##NAME##_create(UList_##NAME* ulist, size_t init_count)                         \
    {                                                                                                       \
        memset(ulist, 0, sizeof(*ulist));                                                                   \
        return ulist_create((void**)&ulist->data, init_count, &ulist->capacity, sizeof(TYPE));              \
    }                                                                                                       \
    static inline int ulist_##NAME##_create_copy(UList_##NAME* from, UList_##NAME* to)                      \
    {                                                                                                       \
        return ulist_create_copy(                                                                           \
            &from->data, from->count, (void**)&to->data, &to->count, &to->capacity, sizeof(TYPE));          \
    }                                                                                                       \
    static inline int ulist_##NAME##_destroy(UList_##NAME* ulist)                                           \
    {                                                                                                       \
        ulist_destroy((void**)&ulist->data);                                                                \
        memset(ulist, 0, sizeof(*ulist));                                                                   \
        return 0;                                                                                           \
    }                                                                                                       \
    static inline int ulist_##NAME##_reserve(UList_##NAME* ulist, size_t new_capacity)                      \
    {                                                                                                       \
        return ulist_reserve((void**)&ulist->data, new_capacity, &ulist->capacity, sizeof(TYPE));           \
    }                                                                                                       \
    static inline int ulist_##NAME##_resize(UList_##NAME* ulist, size_t new_size)                           \
    {                                                                                                       \
        return ulist_resize((void**)&ulist->data, new_size, &ulist->capacity, &ulist->count, sizeof(TYPE)); \
    }                                                                                                       \
    static inline int ulist_##NAME##_add_one(UList_##NAME* ulist, TYPE data)                                \
    {                                                                                                       \
        return ulist_add((void**)&ulist->data, &data, 1, &ulist->count, &ulist->capacity, sizeof(TYPE));    \
    }                                                                                                       \
    static inline int ulist_##NAME##_add(UList_##NAME* ulist, TYPE* data, size_t count)                     \
    {                                                                                                       \
        return ulist_add((void**)&ulist->data, data, count, &ulist->count, &ulist->capacity, sizeof(TYPE)); \
    }                                                                                                       \
    static inline int ulist_##NAME##_remove_one(UList_##NAME* ulist, size_t index)                          \
    {                                                                                                       \
        return ulist_remove(&ulist->data, index, 1, &ulist->count, sizeof(TYPE));                           \
    }                                                                                                       \
    static inline int ulist_##NAME##_remove(UList_##NAME* ulist, size_t index, size_t remove_count)         \
    {                                                                                                       \
        return ulist_remove(&ulist->data, index, remove_count, &ulist->count, sizeof(TYPE));                \
    }                                                                                                       \
    static inline int ulist_##NAME##_pop(UList_##NAME* ulist, TYPE* popped_element)                         \
    {                                                                                                       \
        return ulist_pop(&ulist->data, &ulist->count, popped_element, sizeof(TYPE));                        \
    }                                                                                                       \
    static inline int ulist_##NAME##_relax(UList_##NAME* ulist)                                             \
    {                                                                                                       \
        return ulist_relax((void**)&ulist->data, ulist->count, &ulist->capacity);                           \
    }
#endif

/**********************************/
/****** tinycsocket_posix.h *******/
/**********************************/
/*
 * Copyright 2018 Markus Lindelöw
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files(the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef _POSIX_C_SOURCE
#define _POSIX_C_SOURCE 200112L
#endif
#ifndef _ISOC99_SOURCE
#define _ISOC99_SOURCE
#endif
#ifndef _DEFAULT_SOURCE
#define _DEFAULT_SOURCE
#endif
#ifndef TINYCSOCKET_INTERNAL_H_
#include "tinycsocket_internal.h"
#endif
#ifdef TINYCSOCKET_USE_POSIX_IMPL

#ifdef DO_WRAP
#include "dbg_wrap.h"
#endif

#include <errno.h>
#include <ifaddrs.h>     // getifaddr()
#include <net/if.h>      // Flags for ifaddrs (?)
#include <netdb.h>       // Protocols and custom return codes
#include <netinet/in.h>  // IPPROTO_XXP
#include <netinet/tcp.h> // TCP_NODELAY
#include <poll.h>        // poll()
#include <stdlib.h>      // malloc()/free()
#include <string.h>      // strcpy, memset
#include <sys/ioctl.h>   // Flags for ifaddrs
#include <sys/socket.h>  // pretty much everything
#include <sys/types.h>   // POSIX.1 compatibility
#include <unistd.h>      // close()

const TcsSocket TCS_NULLSOCKET = -1;
const int TCS_INF = -1;

// Addresses
const uint32_t TCS_ADDRESS_ANY_IP4 = INADDR_ANY;
const uint32_t TCS_ADDRESS_LOOPBACK_IP4 = INADDR_LOOPBACK;
const uint32_t TCS_ADDRESS_BROADCAST_IP4 = INADDR_BROADCAST;
const uint32_t TCS_ADDRESS_NONE_IP4 = INADDR_NONE;

// Type
const int TCS_SOCK_STREAM = SOCK_STREAM;
const int TCS_SOCK_DGRAM = SOCK_DGRAM;

// Protocol
const int TCS_IPPROTO_TCP = IPPROTO_TCP;
const int TCS_IPPROTO_UDP = IPPROTO_UDP;

// Flags
const uint32_t TCS_AI_PASSIVE = AI_PASSIVE;

// Recv flags
const uint32_t TCS_MSG_PEEK = MSG_PEEK;
const uint32_t TCS_MSG_OOB = MSG_OOB;
const uint32_t TCS_MSG_WAITALL = MSG_WAITALL;

// Send flags
const uint32_t TCS_MSG_SENDALL = 0x80000000;

// Backlog
const int TCS_BACKLOG_SOMAXCONN = SOMAXCONN;

// Option levels
const int TCS_SOL_SOCKET = SOL_SOCKET;
const int TCS_SOL_IP = IPPROTO_IP; // Same as SOL_IP but crossplatform (BSD)

// Socket options
const int TCS_SO_BROADCAST = SO_BROADCAST;
const int TCS_SO_KEEPALIVE = SO_KEEPALIVE;
const int TCS_SO_LINGER = SO_LINGER;
const int TCS_SO_REUSEADDR = SO_REUSEADDR;
const int TCS_SO_RCVBUF = SO_RCVBUF;
const int TCS_SO_RCVTIMEO = SO_RCVTIMEO;
const int TCS_SO_SNDBUF = SO_SNDBUF;
const int TCS_SO_OOBINLINE = SO_OOBINLINE;

// IP options
const int TCS_SO_IP_NODELAY = TCP_NODELAY;
const int TCS_SO_IP_MEMBERSHIP_ADD = IP_ADD_MEMBERSHIP;
const int TCS_SO_IP_MEMBERSHIP_DROP = IP_DROP_MEMBERSHIP;
const int TCS_SO_IP_MULTICAST_LOOP = IP_MULTICAST_LOOP;

static TcsReturnCode family2native(const TcsAddressFamily family, sa_family_t* native_family)
{
    static uint16_t lut[TCS_AF_LENGTH] = {AF_UNSPEC, AF_INET, AF_INET6};
    if (native_family == NULL)
        return TCS_ERROR_INVALID_ARGUMENT;
    if (family >= TCS_AF_LENGTH || family < 0)
        return TCS_ERROR_INVALID_ARGUMENT;
    *native_family = lut[family];
    return TCS_SUCCESS;
}

static TcsReturnCode errno2retcode(int error_code)
{
    switch (error_code)
    {
        case ECONNREFUSED:
            return TCS_ERROR_CONNECTION_REFUSED;
        default:
            return TCS_ERROR_UNKNOWN;
    }
}

static TcsReturnCode sockaddr2native(const struct TcsAddress* in_addr,
                                     struct sockaddr* out_addr,
                                     socklen_t* out_addrlen)
{
    if (in_addr == NULL || out_addr == NULL)
        return TCS_ERROR_INVALID_ARGUMENT;

    if (in_addr->family == TCS_AF_IP4)
    {
        struct sockaddr_in* addr = (struct sockaddr_in*)out_addr;
        addr->sin_family = (sa_family_t)AF_INET;
        addr->sin_port = (in_port_t)htons(in_addr->data.af_inet.port);
        addr->sin_addr.s_addr = (in_addr_t)htonl(in_addr->data.af_inet.address);

        if (out_addrlen != NULL)
            *out_addrlen = sizeof(struct sockaddr_in);

        return TCS_SUCCESS;
    }
    else if (in_addr->family == TCS_AF_IP6)
    {
        return TCS_ERROR_NOT_IMPLEMENTED;
    }
    else if (in_addr->family == TCS_AF_ANY)
    {
        return TCS_ERROR_NOT_IMPLEMENTED;
    }
    return TCS_ERROR_NOT_IMPLEMENTED;
}

static TcsReturnCode native2sockaddr(const struct sockaddr* in_addr, struct TcsAddress* out_addr)
{
    if (in_addr == NULL || out_addr == NULL)
        return TCS_ERROR_INVALID_ARGUMENT;

    if (in_addr->sa_family == AF_INET)
    {
        struct sockaddr_in* addr = (struct sockaddr_in*)in_addr;
        out_addr->family = TCS_AF_IP4;
        out_addr->data.af_inet.port = ntohs((uint16_t)addr->sin_port);
        out_addr->data.af_inet.address = ntohl((uint32_t)addr->sin_addr.s_addr);
    }
    else if (in_addr->sa_family == AF_INET6)
    {
        return TCS_ERROR_NOT_IMPLEMENTED;
    }
    else if (in_addr->sa_family == AF_UNSPEC)
    {
        return TCS_ERROR_INVALID_ARGUMENT;
    }
    else
    {
        return TCS_ERROR_NOT_IMPLEMENTED;
    }

    return TCS_SUCCESS;
}

TcsReturnCode tcs_lib_init()
{
    // Not needed for posix
    return TCS_SUCCESS;
}

TcsReturnCode tcs_lib_free()
{
    // Not needed for posix
    return TCS_SUCCESS;
}

TcsReturnCode tcs_create_ext(TcsSocket* socket_ctx, TcsAddressFamily family, int type, int protocol)
{
    if (socket_ctx == NULL || *socket_ctx != TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;
    sa_family_t native_family;
    TcsReturnCode sts = family2native(family, &native_family);
    if (sts != TCS_SUCCESS)
        return sts;
    *socket_ctx = socket(native_family, type, protocol);

    if (*socket_ctx != -1) // Same as TCS_NULLSOCKET
        return TCS_SUCCESS;
    else
        return errno2retcode(errno);
}

TcsReturnCode tcs_bind_address(TcsSocket socket_ctx, const struct TcsAddress* address)
{
    if (socket_ctx == TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;

    struct sockaddr_storage native_sockaddr;
    memset(&native_sockaddr, 0, sizeof native_sockaddr);
    socklen_t addrlen = 0;
    TcsReturnCode convert_address_status = sockaddr2native(address, (struct sockaddr*)&native_sockaddr, &addrlen);
    if (convert_address_status != TCS_SUCCESS)
        return convert_address_status;
    if (bind(socket_ctx, (struct sockaddr*)&native_sockaddr, addrlen) != -1)
        return TCS_SUCCESS;
    else
        return errno2retcode(errno);
}

TcsReturnCode tcs_connect_address(TcsSocket socket_ctx, const struct TcsAddress* address)
{
    if (socket_ctx == TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;

    struct sockaddr_storage native_sockaddr;
    memset(&native_sockaddr, 0, sizeof native_sockaddr);
    socklen_t address_length = 0;
    TcsReturnCode convert_address_status =
        sockaddr2native(address, (struct sockaddr*)&native_sockaddr, &address_length);
    if (convert_address_status != TCS_SUCCESS)
        return convert_address_status;

    if (connect(socket_ctx, (const struct sockaddr*)&native_sockaddr, address_length) == 0)
        return TCS_SUCCESS;
    else
        return errno2retcode(errno);
}

TcsReturnCode tcs_listen(TcsSocket socket_ctx, int backlog)
{
    if (socket_ctx == TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;

    if (listen(socket_ctx, backlog) == 0)
        return TCS_SUCCESS;
    else
        return errno2retcode(errno);
}

TcsReturnCode tcs_accept(TcsSocket socket_ctx, TcsSocket* child_socket_ctx, struct TcsAddress* address)
{
    if (socket_ctx == TCS_NULLSOCKET || child_socket_ctx == NULL || *child_socket_ctx != TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;

    struct sockaddr_storage native_sockaddr;
    memset(&native_sockaddr, 0, sizeof native_sockaddr);
    socklen_t address_length = sizeof native_sockaddr;

    *child_socket_ctx = accept(socket_ctx, (struct sockaddr*)&native_sockaddr, &address_length);
    if (*child_socket_ctx != -1)
    {
        if (address != NULL)
        {
            TcsReturnCode convert_address_status = native2sockaddr((struct sockaddr*)&native_sockaddr, address);
            if (convert_address_status != TCS_SUCCESS)
                return convert_address_status;
        }
        return TCS_SUCCESS;
    }
    else
    {
        *child_socket_ctx = TCS_NULLSOCKET;
        return errno2retcode(errno);
    }
}

TcsReturnCode tcs_send(TcsSocket socket_ctx,
                       const uint8_t* buffer,
                       size_t buffer_size,
                       uint32_t flags,
                       size_t* bytes_sent)
{
    if (socket_ctx == TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;

    // Send all
    if (flags & TCS_MSG_SENDALL)
    {
        uint32_t new_flags = flags & ~TCS_MSG_SENDALL; // For recursive call
        size_t left = buffer_size;
        size_t sent = 0;

        while (left > 0)
        {
            TcsReturnCode sts = tcs_send(socket_ctx, buffer, buffer_size, new_flags, &sent);
            if (sts != TCS_SUCCESS)
                return sts;
            left -= sent;
        }
        return TCS_SUCCESS;
    }
    else // Send
    {
        ssize_t send_status = send(socket_ctx, (const char*)buffer, buffer_size, (int)flags);
        if (send_status >= 0)
        {
            if (bytes_sent != NULL)
                *bytes_sent = (size_t)send_status;
            return TCS_SUCCESS;
        }
        else
        {
            if (bytes_sent != NULL)
                *bytes_sent = 0;
            return errno2retcode(errno);
        }
    }
}

TcsReturnCode tcs_send_to(TcsSocket socket_ctx,
                          const uint8_t* buffer,
                          size_t buffer_size,
                          uint32_t flags,
                          const struct TcsAddress* destination_address,
                          size_t* bytes_sent)
{
    if (socket_ctx == TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;

    struct sockaddr_storage native_sockaddr;
    memset(&native_sockaddr, 0, sizeof native_sockaddr);
    socklen_t address_length = 0;
    TcsReturnCode convert_addr_status =
        sockaddr2native(destination_address, (struct sockaddr*)&native_sockaddr, &address_length);
    if (convert_addr_status != TCS_SUCCESS)
        return convert_addr_status;

    ssize_t sendto_status = sendto(socket_ctx,
                                   (const char*)buffer,
                                   buffer_size,
                                   (int)flags,
                                   (const struct sockaddr*)&native_sockaddr,
                                   (socklen_t)address_length);

    if (sendto_status >= 0)
    {
        if (bytes_sent != NULL)
            *bytes_sent = (size_t)sendto_status;
        return TCS_SUCCESS;
    }
    else
    {
        if (bytes_sent != NULL)
            *bytes_sent = 0;

        return errno2retcode(errno);
    }
}

TcsReturnCode tcs_receive(TcsSocket socket_ctx,
                          uint8_t* buffer,
                          size_t buffer_size,
                          uint32_t flags,
                          size_t* bytes_received)
{
    if (socket_ctx == TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;

    ssize_t recv_status = recv(socket_ctx, (char*)buffer, buffer_size, (int)flags);

    if (recv_status > 0)
    {
        if (bytes_received != NULL)
            *bytes_received = (size_t)recv_status;
        return TCS_SUCCESS;
    }
    else if (recv_status == 0)
    {
        if (bytes_received != NULL)
            *bytes_received = 0;
        return TCS_ERROR_NOT_CONNECTED; // TODO: think about this
    }
    else
    {
        if (bytes_received != NULL)
            *bytes_received = 0;
        return errno2retcode(errno);
    }
}

TcsReturnCode tcs_receive_from(TcsSocket socket_ctx,
                               uint8_t* buffer,
                               size_t buffer_size,
                               uint32_t flags,
                               struct TcsAddress* source_address,
                               size_t* bytes_received)
{
    if (socket_ctx == TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;

    struct sockaddr_storage native_sockaddr;
    memset(&native_sockaddr, 0, sizeof native_sockaddr);
    socklen_t addrlen = sizeof native_sockaddr;

    ssize_t recvfrom_status = recvfrom(
        socket_ctx, (char*)buffer, buffer_size, (int)flags, (struct sockaddr*)&native_sockaddr, (socklen_t*)&addrlen);

    if (recvfrom_status > 0)
    {
        if (bytes_received != NULL)
            *bytes_received = (size_t)recvfrom_status;
        if (source_address != NULL)
            return native2sockaddr((struct sockaddr*)&native_sockaddr, source_address);
        return TCS_SUCCESS;
    }
    else if (recvfrom_status == 0)
    {
        if (bytes_received != NULL)
            *bytes_received = 0;
        return TCS_ERROR_SOCKET_CLOSED; // TODO: think about this
    }
    else
    {
        if (bytes_received != NULL)
            *bytes_received = 0;
        return errno2retcode(errno);
    }
}

struct __tcs_fd_poll_vector
{
    size_t capacity;
    size_t count;
    struct pollfd* data;
    void** user_data;
};

struct TcsPool
{
    union __backend
    {
        struct __poll
        {
            struct __tcs_fd_poll_vector vector;
        } poll;
    } backend;
};

static const size_t TCS_POOL_CAPACITY_STEP = 1024;

TcsReturnCode tcs_pool_create(struct TcsPool** pool)
{
    if (pool == NULL || *pool != NULL)
        return TCS_ERROR_INVALID_ARGUMENT;

    *pool = (struct TcsPool*)malloc(sizeof(struct TcsPool));
    if (*pool == NULL)
        return TCS_ERROR_MEMORY;
    memset(*pool, 0, sizeof(struct TcsPool));

    (*pool)->backend.poll.vector.data = (struct pollfd*)malloc(TCS_POOL_CAPACITY_STEP * sizeof(struct pollfd));
    if ((*pool)->backend.poll.vector.data == NULL)
    {
        tcs_pool_destory(pool);
        return TCS_ERROR_MEMORY;
    }
    memset((*pool)->backend.poll.vector.data, 0, TCS_POOL_CAPACITY_STEP * sizeof(struct pollfd));

    (*pool)->backend.poll.vector.user_data = (void**)malloc(TCS_POOL_CAPACITY_STEP * sizeof(void*));
    if ((*pool)->backend.poll.vector.user_data == NULL)
    {
        tcs_pool_destory(pool);
        return TCS_ERROR_MEMORY;
    }

    (*pool)->backend.poll.vector.capacity = TCS_POOL_CAPACITY_STEP;

    return TCS_SUCCESS;
}

TcsReturnCode tcs_pool_destory(struct TcsPool** pool)
{
    if (pool == NULL || *pool == NULL)
        return TCS_ERROR_INVALID_ARGUMENT;

    free((*pool)->backend.poll.vector.data);
    free((*pool)->backend.poll.vector.user_data);
    free(*pool);
    *pool = NULL;

    return TCS_SUCCESS;
}

TcsReturnCode tcs_pool_add(struct TcsPool* pool,
                           TcsSocket socket_ctx,
                           void* user_data,
                           bool poll_can_read,
                           bool poll_can_write,
                           bool poll_error)
{
    if (pool == NULL)
        return TCS_ERROR_INVALID_ARGUMENT;
    if (socket_ctx == TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;
    struct __tcs_fd_poll_vector* vec = &pool->backend.poll.vector;

    // Should not happen, something is corrupted
    if (vec->data == NULL)
        return TCS_ERROR_UNKNOWN;

    if (vec->count >= vec->capacity)
    {
        void* new_data = realloc(vec->data, vec->capacity + TCS_POOL_CAPACITY_STEP);
        if (new_data == NULL)
        {
            return TCS_ERROR_MEMORY;
        }
        void* new_user_data = realloc(vec->user_data, vec->capacity + TCS_POOL_CAPACITY_STEP);
        if (new_user_data == NULL)
        {
            free(new_data);
            return TCS_ERROR_MEMORY;
        }

        vec->data = (struct pollfd*)new_data;
        vec->user_data = (void**)new_user_data;
        vec->capacity += TCS_POOL_CAPACITY_STEP;
    }

    // todo(markusl): Add more events that is input and output events
    short ev = 0;
    if (poll_can_read)
        ev |= POLLIN;
    if (poll_can_write)
        ev |= POLLOUT;
    if (poll_error)
        ev |= POLLERR;

    vec->data[vec->count].fd = socket_ctx;
    vec->data[vec->count].revents = 0;
    vec->data[vec->count].events = ev;
    vec->user_data[vec->count] = user_data;
    vec->count++;

    return TCS_SUCCESS;
}

static TcsReturnCode __tcs_pool_remove_index(struct TcsPool* pool, size_t index)
{
#ifndef NDEBUG
    if (pool == NULL)
        return TCS_ERROR_INVALID_ARGUMENT;
#endif
    struct __tcs_fd_poll_vector* vec = &pool->backend.poll.vector;

    if (index >= vec->count)
        return TCS_ERROR_INVALID_ARGUMENT;

    vec->count--;
    vec->data[index] = vec->data[vec->count];
    vec->user_data[index] = vec->user_data[vec->count];

    bool is_minimum = vec->capacity == TCS_POOL_CAPACITY_STEP;
    bool should_shrink = vec->capacity >= vec->count + 2 * TCS_POOL_CAPACITY_STEP; // hysteresis
    if (!is_minimum && should_shrink)
    {
        // free only one step (two steps can be minimum because of hysteresis)
        void* new_data = realloc(vec->data, vec->capacity - TCS_POOL_CAPACITY_STEP);
        if (new_data == NULL)
            return TCS_ERROR_MEMORY; // Should not happen since we are shrinking

        void* new_user_data = realloc(vec->user_data, vec->capacity - TCS_POOL_CAPACITY_STEP);
        if (new_user_data == NULL)
        {
            free(new_data);
            return TCS_ERROR_MEMORY;
        }

        vec->capacity -= TCS_POOL_CAPACITY_STEP;
        vec->data = (struct pollfd*)new_data;
        vec->user_data = (void**)new_user_data;
    }

    return TCS_SUCCESS;
}

TcsReturnCode tcs_pool_remove(struct TcsPool* pool, TcsSocket socket_ctx)
{
    if (pool == NULL)
        return TCS_ERROR_INVALID_ARGUMENT;
    if (socket_ctx == TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;

    struct __tcs_fd_poll_vector* vec = &pool->backend.poll.vector;

    // Should not happen, something is corrupted
    if (vec->data == NULL)
        return TCS_ERROR_UNKNOWN;

    bool found = false;
    for (size_t i = 0; i < vec->count; ++i)
    {
        if (socket_ctx == vec->data[i].fd)
        {
            TcsReturnCode sts = __tcs_pool_remove_index(pool, i);
            if (sts != TCS_SUCCESS)
                return sts;
            found = true;
            break;
        }
    }
    if (!found)
        return TCS_ERROR_INVALID_ARGUMENT;

    return TCS_SUCCESS;
}

TcsReturnCode tcs_pool_poll(struct TcsPool* pool,
                            struct TcsPollEvent* events,
                            size_t events_count,
                            size_t* events_populated,
                            int64_t timeout_in_ms)
{
    if (pool == NULL)
        return TCS_ERROR_INVALID_ARGUMENT;

    // We do not support more more elements or time than signed int32 supports.
    // todo(markusl): Add support for int64 timeout
    if (events_count > 0x7FFFFFFF || timeout_in_ms > 0x7FFFFFFF)
        return TCS_ERROR_INVALID_ARGUMENT;

    struct __tcs_fd_poll_vector* vec = &pool->backend.poll.vector;

    int ret = poll(vec->data, vec->count, (int)timeout_in_ms);
    if (ret == 0)
    {
        return TCS_ERROR_TIMED_OUT;
    }
    else if (ret < 0)
    {
        return errno2retcode(errno);
    }
    else if ((size_t)ret > vec->count)
    {
        return TCS_ERROR_UNKNOWN; // Corruption?
    }

    int fill_max = ret > (int)events_count ? (int)events_count : ret; // min(ret, events_count)
    int filled = 0;
    size_t n = 0;
    while (filled < fill_max)
    {
#ifndef NDEBUG
        if (n >= vec->count)
            return TCS_ERROR_UNKNOWN;
#endif
        if (vec->data[n].revents != 0)
        {
            events[filled].socket = vec->data[n].fd;
            events[filled].user_data = vec->user_data[n];
            events[filled].can_read = vec->data[n].revents & POLLIN;
            events[filled].can_write = vec->data[n].revents & POLLOUT;
            events[filled].error = (TcsReturnCode)(vec->data[n].revents & POLLERR);
            filled++;
            TcsReturnCode sts = __tcs_pool_remove_index(pool, n);
            if (sts != TCS_SUCCESS)
                return sts;
            // n will now be contain a new element after remove index, therefor do not increase n
        }
        else
        {
            n++;
        }
    }
    if (events_populated != NULL)
        *events_populated = (size_t)filled; // guaranteed > 0

    return TCS_SUCCESS;
}

TcsReturnCode tcs_set_option(TcsSocket socket_ctx,
                             int32_t level,
                             int32_t option_name,
                             const void* option_value,
                             size_t option_size)
{
    if (socket_ctx == TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;

    if (setsockopt(socket_ctx, (int)level, (int)option_name, (const char*)option_value, (socklen_t)option_size) == 0)
        return TCS_SUCCESS;
    else
        return errno2retcode(errno);
}

TcsReturnCode tcs_get_option(TcsSocket socket_ctx,
                             int32_t level,
                             int32_t option_name,
                             void* option_value,
                             size_t* option_size)
{
    if (socket_ctx == TCS_NULLSOCKET || option_value == NULL || option_size == NULL)
        return TCS_ERROR_INVALID_ARGUMENT;

    if (getsockopt(socket_ctx, (int)level, (int)option_name, (void*)option_value, (socklen_t*)option_size) == 0)
    {
        // Linux sets the buffer size to the doubled because of internal use and returns the full doubled size including internal part
#ifdef __linux__
        if (option_name == TCS_SO_RCVBUF || option_name == TCS_SO_SNDBUF)
        {
            *(unsigned int*)option_value /= 2;
        }
#endif
        return TCS_SUCCESS;
    }
    else
    {
        return errno2retcode(errno);
    }
}

TcsReturnCode tcs_shutdown(TcsSocket socket_ctx, TcsSocketDirection direction)
{
    const int LUT[] = {SHUT_RD, SHUT_WR, SHUT_RDWR};

    if (socket_ctx == TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;

    const int how = LUT[direction];
    if (shutdown(socket_ctx, how) == 0)
        return TCS_SUCCESS;
    else
        return errno2retcode(errno);
}

TcsReturnCode tcs_destroy(TcsSocket* socket_ctx)
{
    if (socket_ctx == NULL || *socket_ctx == TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;

    if (close(*socket_ctx) == 0)
    {
        *socket_ctx = TCS_NULLSOCKET;
        return TCS_SUCCESS;
    }
    else
    {
        return errno2retcode(errno);
    }
}

TcsReturnCode tcs_resolve_hostname(const char* hostname,
                                   TcsAddressFamily address_family,
                                   struct TcsAddress found_addresses[],
                                   size_t found_addresses_length,
                                   size_t* no_of_found_addresses)
{
    if (hostname == NULL)
        return TCS_ERROR_INVALID_ARGUMENT;

    if (found_addresses == NULL && no_of_found_addresses == NULL)
        return TCS_ERROR_INVALID_ARGUMENT;

    if (no_of_found_addresses != NULL)
        *no_of_found_addresses = 0;

    struct addrinfo native_hints;
    memset(&native_hints, 0, sizeof native_hints);
    TcsReturnCode family_convert_status = family2native(address_family, (sa_family_t*)&native_hints.ai_family);
    if (family_convert_status != TCS_SUCCESS)
        return family_convert_status;

    struct addrinfo* native_addrinfo_list = NULL;
    int sts = getaddrinfo(hostname, NULL, &native_hints, &native_addrinfo_list);
    if (sts == EAI_SYSTEM)
        return errno2retcode(errno);
    else if (native_addrinfo_list == NULL)
        return TCS_ERROR_UNKNOWN;
    else if (sts != 0)
        return TCS_ERROR_UNKNOWN;

    size_t i = 0;
    if (found_addresses == NULL)
    {
        for (struct addrinfo* iter = native_addrinfo_list; iter != NULL; iter = iter->ai_next)
            i++;
    }
    else
    {
        for (struct addrinfo* iter = native_addrinfo_list; iter != NULL && i < found_addresses_length;
             iter = iter->ai_next)
        {
            TcsReturnCode convert_address_status = native2sockaddr(iter->ai_addr, &found_addresses[i]);
            if (convert_address_status != TCS_SUCCESS)
                continue;
            i++;
        }
    }
    if (no_of_found_addresses != NULL)
        *no_of_found_addresses = i;

    freeaddrinfo(native_addrinfo_list);

    if (i == 0)
        return TCS_ERROR_ADDRESS_LOOKUP_FAILED;

    return TCS_SUCCESS;
}

// This is not part of posix, we need to be platform specific here
#if TCS_HAVE_IFADDRS // acquired from CMake
TcsReturnCode tcs_local_interfaces(struct TcsInterface found_interfaces[],
                                   size_t found_interfaces_length,
                                   size_t* no_of_found_interfaces)
{
    if (found_interfaces == NULL && no_of_found_interfaces == NULL)
        return TCS_ERROR_INVALID_ARGUMENT;

    if (found_interfaces == NULL && found_interfaces_length != 0)
        return TCS_ERROR_INVALID_ARGUMENT;

    if (no_of_found_interfaces != NULL)
        *no_of_found_interfaces = 0;

    struct ifaddrs* interfaces;
    getifaddrs(&interfaces);
    size_t i = 0;

    for (struct ifaddrs* iter = interfaces; iter != NULL && (found_interfaces == NULL || i < found_interfaces_length);
         iter = iter->ifa_next)
    {
        if (iter->ifa_flags & IFF_UP)
        {
            struct TcsAddress t;
            if (native2sockaddr(iter->ifa_addr, &t) != TCS_SUCCESS)
                continue;
            if (found_interfaces != NULL)
            {
                found_interfaces[i].address = t;
                strncpy(found_interfaces[i].name, iter->ifa_name, 31);
                found_interfaces[i].name[31] = '\0';
            }
            i++;
        }
    }
    freeifaddrs(interfaces);
    if (no_of_found_interfaces != NULL)
        *no_of_found_interfaces = i;
    return TCS_SUCCESS;
}
#else
// SunOS before 2010, HP and AIX does not support getifaddrs
// ioctl implementation,
// https://stackoverflow.com/questions/4139405/how-can-i-get-to-know-the-ip-address-for-interfaces-in-c/4139811#4139811
TcsReturnCode tcs_local_interfaces(struct TcsInterface found_interfaces[],
                                   size_t found_interfaces_length,
                                   size_t* no_of_found_interfaces)
{
    if (found_interfaces == NULL && no_of_found_interfaces == NULL)
        return TCS_ERROR_INVALID_ARGUMENT;

    if (found_interfaces == NULL && found_interfaces_length != 0)
        return TCS_ERROR_INVALID_ARGUMENT;

    if (no_of_found_interfaces != NULL)
        *no_of_found_interfaces = 0;

    int fd = socket(PF_INET, SOCK_DGRAM, 0);
    if (fd < 0)
        return TCS_ERROR_UNKNOWN;

    struct ifconf adapters;
    char buf[16384];
    adapters.ifc_len = sizeof(buf);
    adapters.ifc_buf = buf;
    if (ioctl(fd, SIOCGIFCONF, &adapters) != 0) // todo(markus): add tries as for Windows
    {
        close(fd);
        return TCS_ERROR_UNKNOWN;
    }

    struct ifreq* ifr_iterator = adapters.ifc_req;
    int offset = 0;
    int len;
    size_t i = 0;
    while (offset < adapters.ifc_len)
    {
        // todo(markusl): we need to investigate which OS uses which system, scheduled to after CI with multiple OS
#ifndef __linux__
        len = IFNAMSIZ + ifr_iterator->ifr_addr.sa_len;
#else
        len = sizeof(struct ifreq);
#endif
        if (found_interfaces != NULL)
        {
            native2sockaddr((struct sockaddr*)&ifr_iterator->ifr_addr, &found_interfaces[i].address);
            strncpy(found_interfaces[i].name, ifr_iterator->ifr_name, 31);
            found_interfaces[i].name[31] = '\0';
        }
        ++i;
        ifr_iterator = (struct ifreq*)((uint8_t*)ifr_iterator + len);
        offset += len;
    }
    if (no_of_found_interfaces != NULL)
        *no_of_found_interfaces = i;
    close(fd);
    return TCS_SUCCESS;
}
#endif

TcsReturnCode tcs_set_linger(TcsSocket socket_ctx, bool do_linger, int timeout_seconds)
{
    if (socket_ctx == TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;

    struct linger l = {(u_short)do_linger, (u_short)timeout_seconds};
    return tcs_set_option(socket_ctx, TCS_SOL_SOCKET, TCS_SO_LINGER, &l, sizeof(l));
}

TcsReturnCode tcs_get_linger(TcsSocket socket_ctx, bool* do_linger, int* timeout_seconds)
{
    if (socket_ctx == TCS_NULLSOCKET || (do_linger == NULL && timeout_seconds == NULL))
        return TCS_ERROR_INVALID_ARGUMENT;

    struct linger l = {0, 0};
    size_t l_size = sizeof(l);
    TcsReturnCode sts = tcs_get_option(socket_ctx, TCS_SOL_SOCKET, TCS_SO_LINGER, &l, &l_size);
    if (sts == TCS_SUCCESS)
    {
        if (do_linger)
            *do_linger = l.l_onoff;
        if (timeout_seconds)
            *timeout_seconds = l.l_linger;
    }

    return sts;
}

TcsReturnCode tcs_set_receive_timeout(TcsSocket socket_ctx, int timeout_ms)
{
    if (socket_ctx == TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;

    struct timeval tv;
    tv.tv_sec = timeout_ms / 1000;
    tv.tv_usec = (timeout_ms % 1000) * 1000;

    return tcs_set_option(socket_ctx, TCS_SOL_SOCKET, TCS_SO_RCVTIMEO, &tv, sizeof(tv));
}

TcsReturnCode tcs_get_receive_timeout(TcsSocket socket_ctx, int* timeout_ms)
{
    if (socket_ctx == TCS_NULLSOCKET || timeout_ms == NULL)
        return TCS_ERROR_INVALID_ARGUMENT;

    struct timeval tv = {0, 0};
    size_t tv_size = sizeof(tv);
    TcsReturnCode sts = tcs_get_option(socket_ctx, TCS_SOL_SOCKET, TCS_SO_RCVTIMEO, &tv, &tv_size);

    if (sts == TCS_SUCCESS)
    {
        int c = 0;
        c += (int)tv.tv_sec * 1000;
        c += (int)tv.tv_usec / 1000;
        *timeout_ms = c;
    }
    return sts;
}

TcsReturnCode tcs_set_ip_multicast_add(TcsSocket socket_ctx,
                                       const struct TcsAddress* local_address,
                                       const struct TcsAddress* multicast_address)
{
    if (multicast_address == NULL)
        return TCS_ERROR_INVALID_ARGUMENT;

    // Override here to remove error

    struct sockaddr_storage address_native_multicast;
    memset(&address_native_multicast, 0, sizeof address_native_multicast);
    socklen_t address_native_multicast_size = 0;
    TcsReturnCode mutlicast_to_native_sts =
        sockaddr2native(multicast_address, (struct sockaddr*)&address_native_multicast, &address_native_multicast_size);
    if (mutlicast_to_native_sts != TCS_SUCCESS)
        return mutlicast_to_native_sts;

    struct sockaddr_storage address_native_local;
    memset(&address_native_local, 0, sizeof address_native_local);
    socklen_t address_native_local_size = 0;
    if (local_address != NULL)
    {
        TcsReturnCode mutlicast_to_local_sts =
            sockaddr2native(local_address, (struct sockaddr*)&address_native_local, &address_native_local_size);
        if (mutlicast_to_local_sts)
            return mutlicast_to_local_sts;
    }

    if (multicast_address->family == TCS_AF_IP4)
    {
        struct sockaddr_in* address_native_multicast_p = (struct sockaddr_in*)&address_native_multicast;
        struct sockaddr_in* address_native_local_p = (struct sockaddr_in*)&address_native_local;

        struct ip_mreq mreq;
        memset(&mreq, 0, sizeof mreq);

        mreq.imr_interface.s_addr = address_native_local_p->sin_addr.s_addr;
        mreq.imr_multiaddr.s_addr = address_native_multicast_p->sin_addr.s_addr;

        return tcs_set_option(socket_ctx, TCS_SOL_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq));
    }
    else
    {
        // TODO(markusl): Add ipv6 support
        return TCS_ERROR_NOT_IMPLEMENTED;
    }
}

TcsReturnCode tcs_set_ip_multicast_drop(TcsSocket socket_ctx,
                                        const struct TcsAddress* local_address,
                                        const struct TcsAddress* multicast_address)
{
    if (multicast_address == NULL)
        return TCS_ERROR_INVALID_ARGUMENT;

    struct sockaddr_storage address_native_multicast;
    memset(&address_native_multicast, 0, sizeof address_native_multicast);
    socklen_t address_native_multicast_size = 0;
    TcsReturnCode mutlicast_to_native_sts =
        sockaddr2native(multicast_address, (struct sockaddr*)&address_native_multicast, &address_native_multicast_size);
    if (mutlicast_to_native_sts != TCS_SUCCESS)
        return mutlicast_to_native_sts;

    struct sockaddr_storage address_native_local;
    memset(&address_native_local, 0, sizeof address_native_local);
    socklen_t address_native_local_size = 0;
    if (local_address != NULL)
    {
        TcsReturnCode mutlicast_to_local_sts =
            sockaddr2native(local_address, (struct sockaddr*)&address_native_local, &address_native_local_size);
        if (mutlicast_to_local_sts)
            return mutlicast_to_local_sts;
    }

    if (multicast_address->family == TCS_AF_IP4)
    {
        struct sockaddr_in* address_native_multicast_p = (struct sockaddr_in*)&address_native_multicast;
        struct sockaddr_in* address_native_local_p = (struct sockaddr_in*)&address_native_local;

        struct ip_mreq mreq;
        memset(&mreq, 0, sizeof mreq);

        mreq.imr_interface.s_addr = address_native_local_p->sin_addr.s_addr;
        mreq.imr_multiaddr.s_addr = address_native_multicast_p->sin_addr.s_addr;

        return tcs_set_option(socket_ctx, TCS_SOL_IP, IP_DROP_MEMBERSHIP, &mreq, sizeof(mreq));
    }
    else
    {
        // TODO(markusl): Add ipv6 support
        return TCS_ERROR_NOT_IMPLEMENTED;
    }
}

#endif

/**********************************/
/****** tinycsocket_win32.h *******/
/**********************************/
/*
 * Copyright 2018 Markus Lindelöw
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files(the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
#ifndef TINYCSOCKET_INTERNAL_H_
#include "tinycsocket_internal.h"
#endif
#ifdef TINYCSOCKET_USE_WIN32_IMPL

#ifdef DO_WRAP
#include "dbg_wrap.h"
#endif

#if !defined(NTDDI_VERSION) && !defined(_WIN32_WINNT) && !defined(WINVER)
#ifdef _WIN64
#define NTDDI_VERSION 0x05020000
#define _WIN32_WINNT 0x0502
#define WINVER 0x0502
#else
#define NTDDI_VERSION 0x05010300
#define _WIN32_WINNT 0x0501
#define WINVER 0x0501
#endif
#endif
#define WIN32_LEAN_AND_MEAN
// Header only should not need other files
#ifndef TINYDATASTRUCTURES_H_
#include "tinydatastructures.h"
#endif
// before windows.h
#include <winsock2.h> // sockets

#include <windows.h>

// after windows.h
#include <iphlpapi.h> // GetAdaptersAddresses
#include <ws2tcpip.h> // getaddrinfo

#include <stdlib.h> // Malloc for GetAdaptersAddresses
#include <string.h> // memset

#if defined(_MSC_VER) || defined(__clang__)
#pragma comment(lib, "wsock32.lib")
#pragma comment(lib, "ws2_32.lib")
#pragma comment(lib, "Iphlpapi.lib")
#endif

#ifdef __cplusplus
using std::min;
#endif

// Forwards declaration due to winver dispatch
// We will dispatch at lib_init() which OS functions to call depending on OS support

TDS_ULIST_IMPL(SOCKET, soc)

// Needs to be compatible with fd_set, hopefully this works
struct tcs_fd_set
{
    u_int fd_count;
    SOCKET fd_array[1]; // dynamic memory hack that is compatible with Win32 API fd_set
};

struct tcs_usr_data_vector
{
    SOCKET* key;
    void** value;
    size_t capacity_bytes;
    size_t count;
};

struct TcsPool
{
    UList_soc read_sockets;
    UList_soc write_sockets;
    UList_soc error_sockets;
    struct tcs_usr_data_vector user_data;
};

static const size_t TCS_POOL_CAPACITY_STEP = 1024;

const TcsSocket TCS_NULLSOCKET = INVALID_SOCKET;
const int TCS_INF = -1;

// Addresses
const uint32_t TCS_ADDRESS_ANY_IP4 = INADDR_ANY;
const uint32_t TCS_ADDRESS_LOOPBACK_IP4 = INADDR_LOOPBACK;
const uint32_t TCS_ADDRESS_BROADCAST_IP4 = INADDR_BROADCAST;
const uint32_t TCS_ADDRESS_NONE_IP4 = INADDR_NONE;

// Type
const int TCS_SOCK_STREAM = SOCK_STREAM;
const int TCS_SOCK_DGRAM = SOCK_DGRAM;

// Protocol
const int TCS_IPPROTO_TCP = IPPROTO_TCP;
const int TCS_IPPROTO_UDP = IPPROTO_UDP;

// Flags
const uint32_t TCS_AI_PASSIVE = AI_PASSIVE;

// Recv flags
const uint32_t TCS_MSG_PEEK = MSG_PEEK;
const uint32_t TCS_MSG_OOB = MSG_OOB;
const uint32_t TCS_MSG_WAITALL = 0x8; // Binary compatible when it does not exist

// Send flags
const uint32_t TCS_MSG_SENDALL = 0x80000000;

// Backlog
const int TCS_BACKLOG_SOMAXCONN = SOMAXCONN;

// Option levels
const int TCS_SOL_SOCKET = SOL_SOCKET;
const int TCS_SOL_IP = IPPROTO_IP;

// Socket options
const int TCS_SO_BROADCAST = SO_BROADCAST;
const int TCS_SO_KEEPALIVE = SO_KEEPALIVE;
const int TCS_SO_LINGER = SO_LINGER;
const int TCS_SO_REUSEADDR = SO_REUSEADDR;
const int TCS_SO_RCVBUF = SO_RCVBUF;
const int TCS_SO_RCVTIMEO = SO_RCVTIMEO;
const int TCS_SO_SNDBUF = SO_SNDBUF;
const int TCS_SO_OOBINLINE = SO_OOBINLINE;

// IP options
const int TCS_SO_IP_NODELAY = TCP_NODELAY;
const int TCS_SO_IP_MEMBERSHIP_ADD = IP_ADD_MEMBERSHIP;
const int TCS_SO_IP_MEMBERSHIP_DROP = IP_DROP_MEMBERSHIP;
const int TCS_SO_IP_MULTICAST_LOOP = IP_MULTICAST_LOOP;

int g_init_count = 0;

static TcsReturnCode wsaerror2retcode(int wsa_error)
{
    switch (wsa_error)
    {
        case WSANOTINITIALISED:
            return TCS_ERROR_NOT_INITED;
        case WSAEWOULDBLOCK:
            return TCS_ERROR_WOULD_BLOCK;
        default:
            return TCS_ERROR_UNKNOWN;
    }
}

static TcsReturnCode socketstatus2retcode(int status)
{
    if (status == 0)
    {
        return TCS_SUCCESS;
    }
    else if (status == SOCKET_ERROR)
    {
        int error_code = WSAGetLastError();
        return wsaerror2retcode(error_code);
    }
    else
    {
        return TCS_ERROR_UNKNOWN;
    }
}

static TcsReturnCode family2native(const TcsAddressFamily family, short* native_family)
{
    static short lut[TCS_AF_LENGTH] = {AF_UNSPEC, AF_INET, AF_INET6};
    if (native_family == NULL)
        return TCS_ERROR_INVALID_ARGUMENT;
    if (family >= TCS_AF_LENGTH || family < 0)
        return TCS_ERROR_INVALID_ARGUMENT;
    *native_family = lut[family];
    return TCS_SUCCESS;
}

static TcsReturnCode sockaddr2native(const struct TcsAddress* in_addr, PSOCKADDR out_addr, int* out_addrlen)
{
    if (in_addr == NULL || out_addr == NULL)
        return TCS_ERROR_INVALID_ARGUMENT;

    if (in_addr->family == TCS_AF_IP4)
    {
        PSOCKADDR_IN addr = (PSOCKADDR_IN)out_addr;
        addr->sin_family = (ADDRESS_FAMILY)AF_INET;
        addr->sin_port = htons((USHORT)in_addr->data.af_inet.port);
        addr->sin_addr.S_un.S_addr = htonl((ULONG)in_addr->data.af_inet.address);

        if (out_addrlen != NULL)
            *out_addrlen = sizeof(SOCKADDR_IN);

        return TCS_SUCCESS;
    }
    else if (in_addr->family == TCS_AF_IP6)
    {
        return TCS_ERROR_NOT_IMPLEMENTED;
    }
    else if (in_addr->family == TCS_AF_ANY)
    {
        return TCS_ERROR_NOT_IMPLEMENTED;
    }
    return TCS_ERROR_NOT_IMPLEMENTED;
}

static TcsReturnCode native2sockaddr(const PSOCKADDR in_addr, struct TcsAddress* out_addr)
{
    if (in_addr == NULL || out_addr == NULL)
        return TCS_ERROR_INVALID_ARGUMENT;

    if (in_addr->sa_family == AF_INET)
    {
        PSOCKADDR_IN addr = (PSOCKADDR_IN)in_addr;
        out_addr->family = TCS_AF_IP4;
        out_addr->data.af_inet.port = ntohs((uint16_t)addr->sin_port);
        out_addr->data.af_inet.address = ntohl((uint32_t)addr->sin_addr.S_un.S_addr);
    }
    else if (in_addr->sa_family == AF_INET6)
    {
        return TCS_ERROR_NOT_IMPLEMENTED;
    }
    else if (in_addr->sa_family == AF_UNSPEC)
    {
        return TCS_ERROR_INVALID_ARGUMENT;
    }
    else
    {
        return TCS_ERROR_NOT_IMPLEMENTED;
    }

    return TCS_SUCCESS;
}

TcsReturnCode tcs_lib_init()
{
    if (g_init_count <= 0)
    {
        WSADATA wsa_data;
        int wsa_startup_status_code = WSAStartup(MAKEWORD(2, 2), &wsa_data);
        if (wsa_startup_status_code != 0)
            return TCS_ERROR_KERNEL;
    }
    ++g_init_count;
    return TCS_SUCCESS;
}

TcsReturnCode tcs_lib_free()
{
    g_init_count--;
    if (g_init_count <= 0)
    {
        WSACleanup();
    }
    return TCS_SUCCESS;
}

TcsReturnCode tcs_create_ext(TcsSocket* socket_ctx, TcsAddressFamily family, int type, int protocol)
{
    if (socket_ctx == NULL || *socket_ctx != TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;

    short native_family = AF_UNSPEC;
    TcsReturnCode sts = family2native(family, &native_family);
    if (sts != TCS_SUCCESS)
        return sts;

    TcsSocket new_socket = socket(native_family, type, protocol);

    if (new_socket != INVALID_SOCKET)
    {
        *socket_ctx = new_socket;
        return TCS_SUCCESS;
    }
    else
    {
        int error_code = WSAGetLastError();
        return wsaerror2retcode(error_code);
    }
}

TcsReturnCode tcs_bind_address(TcsSocket socket_ctx, const struct TcsAddress* address)
{
    if (socket_ctx == TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;

    SOCKADDR_STORAGE native_sockaddr;
    memset(&native_sockaddr, 0, sizeof native_sockaddr);
    int addrlen = 0;
    TcsReturnCode convert_addr_status = sockaddr2native(address, (PSOCKADDR)&native_sockaddr, &addrlen);
    if (convert_addr_status != TCS_SUCCESS)
        return convert_addr_status;
    int bind_status = bind(socket_ctx, (PSOCKADDR)&native_sockaddr, addrlen);
    return socketstatus2retcode(bind_status);
}

TcsReturnCode tcs_connect_address(TcsSocket socket_ctx, const struct TcsAddress* address)
{
    if (socket_ctx == TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;

    SOCKADDR_STORAGE native_sockaddr;
    memset(&native_sockaddr, 0, sizeof native_sockaddr);
    int addrlen = 0;
    TcsReturnCode convert_addr_status = sockaddr2native(address, (PSOCKADDR)&native_sockaddr, &addrlen);
    if (convert_addr_status != TCS_SUCCESS)
        return convert_addr_status;
    int connect_status = connect(socket_ctx, (PSOCKADDR)&native_sockaddr, addrlen);
    return socketstatus2retcode(connect_status);
}

TcsReturnCode tcs_listen(TcsSocket socket_ctx, int backlog)
{
    if (socket_ctx == TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;

    int status = listen(socket_ctx, (int)backlog);
    return socketstatus2retcode(status);
}

TcsReturnCode tcs_accept(TcsSocket socket_ctx, TcsSocket* child_socket_ctx, struct TcsAddress* address)
{
    if (socket_ctx == TCS_NULLSOCKET || child_socket_ctx == NULL || *child_socket_ctx != TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;

    SOCKADDR_STORAGE native_sockaddr;
    memset(&native_sockaddr, 0, sizeof native_sockaddr);
    int addr_len = sizeof(native_sockaddr);
    *child_socket_ctx = accept(socket_ctx, (PSOCKADDR)&native_sockaddr, &addr_len);
    if (*child_socket_ctx != INVALID_SOCKET)
    {
        if (address != NULL)
        {
            TcsReturnCode convert_addr_status = native2sockaddr((PSOCKADDR)&native_sockaddr, address);
            if (convert_addr_status != TCS_SUCCESS)
                return convert_addr_status;
        }
        return TCS_SUCCESS;
    }
    else
    {
        *child_socket_ctx = TCS_NULLSOCKET;
        int error_code = WSAGetLastError();
        return wsaerror2retcode(error_code);
    }
}

TcsReturnCode tcs_send(TcsSocket socket_ctx,
                       const uint8_t* buffer,
                       size_t buffer_size,
                       uint32_t flags,
                       size_t* bytes_sent)
{
    if (socket_ctx == TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;

    // Send all
    if (flags & TCS_MSG_SENDALL)
    {
        uint32_t new_flags = flags & ~TCS_MSG_SENDALL; // For recursive call
        size_t left = buffer_size;
        size_t sent = 0;

        while (left > 0)
        {
            TcsReturnCode sts = tcs_send(socket_ctx, buffer, buffer_size, new_flags, &sent);
            if (sts != TCS_SUCCESS)
                return sts;
            left -= sent;
        }
        return TCS_SUCCESS;
    }
    else // Send
    {
        int send_status = send(socket_ctx, (const char*)buffer, (int)buffer_size, (int)flags);
        if (send_status != SOCKET_ERROR)
        {
            if (bytes_sent != NULL)
                *bytes_sent = (size_t)send_status;
            return TCS_SUCCESS;
        }
        else
        {
            if (bytes_sent != NULL)
                *bytes_sent = 0;

            return socketstatus2retcode(send_status);
        }
    }
}

TcsReturnCode tcs_send_to(TcsSocket socket_ctx,
                          const uint8_t* buffer,
                          size_t buffer_size,
                          uint32_t flags,
                          const struct TcsAddress* destination_address,
                          size_t* bytes_sent)
{
    if (socket_ctx == TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;

    SOCKADDR_STORAGE native_sockaddr;
    memset(&native_sockaddr, 0, sizeof native_sockaddr);
    int addrlen = 0;
    TcsReturnCode convert_addr_status = sockaddr2native(destination_address, (PSOCKADDR)&native_sockaddr, &addrlen);
    if (convert_addr_status != TCS_SUCCESS)
        return convert_addr_status;

    int sendto_status =
        sendto(socket_ctx, (const char*)buffer, (int)buffer_size, (int)flags, (PSOCKADDR)&native_sockaddr, addrlen);

    if (sendto_status != SOCKET_ERROR)
    {
        if (bytes_sent != NULL)
            *bytes_sent = (size_t)sendto_status;
        return TCS_SUCCESS;
    }
    else
    {
        if (bytes_sent != NULL)
            *bytes_sent = 0;

        return socketstatus2retcode(sendto_status);
    }
}

TcsReturnCode tcs_receive(TcsSocket socket_ctx,
                          uint8_t* buffer,
                          size_t buffer_size,
                          uint32_t flags,
                          size_t* bytes_received)
{
    if (socket_ctx == TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;

#if WINVER <= 0x501
    if (flags & TCS_MSG_WAITALL)
    {
        uint32_t new_flags = flags & ~TCS_MSG_WAITALL; // Unmask for recursive call
        size_t received_so_far = 0;
        while (received_so_far < buffer_size)
        {
            size_t received_now = 0;
            uint8_t* cursor = buffer + received_so_far;
            size_t left = buffer_size - received_so_far;
            TcsReturnCode sts = tcs_receive(socket_ctx, cursor, left, new_flags, &received_now);
            if (sts != TCS_SUCCESS)
                return sts;
            received_so_far += received_now;
        }
        if (bytes_received != NULL)
            *bytes_received = 0;
        return TCS_SUCCESS;
    }
#endif

    int recv_status = recv(socket_ctx, (char*)buffer, (int)buffer_size, (int)flags);

    if (recv_status == 0)
    {
        return TCS_ERROR_SOCKET_CLOSED;
    }
    else if (recv_status != SOCKET_ERROR)
    {
        if (bytes_received != NULL)
            *bytes_received = (size_t)recv_status;
        return TCS_SUCCESS;
    }
    else
    {
        if (bytes_received != NULL)
            *bytes_received = 0;

        return socketstatus2retcode(recv_status);
    }
}

TcsReturnCode tcs_receive_from(TcsSocket socket_ctx,
                               uint8_t* buffer,
                               size_t buffer_size,
                               uint32_t flags,
                               struct TcsAddress* source_address,
                               size_t* bytes_received)
{
    if (socket_ctx == TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;

    SOCKADDR_STORAGE native_sockaddr;
    memset(&native_sockaddr, 0, sizeof native_sockaddr);
    int addrlen = sizeof(native_sockaddr);

    int recvfrom_status =
        recvfrom(socket_ctx, (char*)buffer, (int)buffer_size, (int)flags, (PSOCKADDR)&native_sockaddr, &addrlen);

    if (recvfrom_status == 0)
    {
        return TCS_ERROR_SOCKET_CLOSED;
    }
    else if (recvfrom_status != SOCKET_ERROR)
    {
        if (bytes_received != NULL)
            *bytes_received = (size_t)recvfrom_status;

        if (source_address != NULL)
        {
            TcsReturnCode convert_address_status = native2sockaddr((PSOCKADDR)&native_sockaddr, source_address);
            return convert_address_status;
        }

        return TCS_SUCCESS;
    }
    else
    {
        if (bytes_received != NULL)
            *bytes_received = 0;

        return socketstatus2retcode(recvfrom_status);
    }
}

TcsReturnCode tcs_pool_create(struct TcsPool** pool)
{
    if (pool == NULL || *pool != NULL)
        return TCS_ERROR_INVALID_ARGUMENT;

    *pool = (struct TcsPool*)malloc(sizeof(struct TcsPool));
    if (*pool == NULL)
        return TCS_ERROR_MEMORY;
    memset(*pool, 0, sizeof(struct TcsPool)); // Just to be safe
    int sts_read_array = ulist_soc_create(&(*pool)->read_sockets, 64);
    int sts_write_array = ulist_soc_create(&(*pool)->write_sockets, 64);
    int sts_error_array = ulist_soc_create(&(*pool)->error_sockets, 64);

    // TODO(markusl): Create a common vector structure
    (*pool)->user_data.key = (SOCKET*)malloc(sizeof(SOCKET) * TCS_POOL_CAPACITY_STEP);
    (*pool)->user_data.value = (void**)malloc(sizeof(void*) * TCS_POOL_CAPACITY_STEP);
    (*pool)->user_data.count = 0;
    (*pool)->user_data.capacity_bytes = TCS_POOL_CAPACITY_STEP;
    TcsReturnCode sts_usrdata = TCS_SUCCESS;
    if ((*pool)->user_data.key == NULL || (*pool)->user_data.value == NULL)
        sts_usrdata = TCS_ERROR_MEMORY;

    if (sts_usrdata != TCS_SUCCESS || sts_read_array != 0 || sts_write_array != TCS_SUCCESS ||
        sts_error_array != TCS_SUCCESS)
    {
        tcs_pool_destory(pool);
        return TCS_ERROR_MEMORY;
    }
    return TCS_SUCCESS;
}

TcsReturnCode tcs_pool_destory(struct TcsPool** pool)
{
    if (pool == NULL || *pool == NULL)
        return TCS_ERROR_INVALID_ARGUMENT;

    // Free away!
    ulist_soc_destroy(&(*pool)->read_sockets);
    ulist_soc_destroy(&(*pool)->write_sockets);
    ulist_soc_destroy(&(*pool)->error_sockets);

    free((*pool)->user_data.key);
    free((*pool)->user_data.value);
    free(*pool);
    *pool = NULL;

    return TCS_SUCCESS;
}

TcsReturnCode tcs_pool_add(struct TcsPool* pool,
                           TcsSocket socket_ctx,
                           void* user_data,
                           bool poll_can_read,
                           bool poll_can_write,
                           bool poll_error)
{
    if (pool == NULL)
        return TCS_ERROR_INVALID_ARGUMENT;
    if (!poll_can_read && !poll_can_write && !poll_error)
        return TCS_ERROR_INVALID_ARGUMENT;

    if (pool->user_data.count == pool->user_data.capacity_bytes)
    {
        size_t new_capacity = pool->user_data.capacity_bytes + TCS_POOL_CAPACITY_STEP;
        SOCKET* new_key = (SOCKET*)realloc(pool->user_data.key, sizeof(SOCKET) * new_capacity);
        if (new_key == NULL)
            return TCS_ERROR_MEMORY;
        pool->user_data.key = new_key;

        void** new_value = (void**)realloc(pool->user_data.value, sizeof(void*) * new_capacity);
        if (new_value == NULL)
        {
            new_key = (SOCKET*)realloc(pool->user_data.key, sizeof(SOCKET) * pool->user_data.capacity_bytes);
            if (new_key != NULL)
                pool->user_data.key = new_key;
            return TCS_ERROR_MEMORY;
        }
        pool->user_data.value = new_value;
        pool->user_data.capacity_bytes = new_capacity;
    }
    pool->user_data.key[pool->user_data.count] = socket_ctx;
    pool->user_data.value[pool->user_data.count] = user_data;
    pool->user_data.count++;

    if (poll_can_read)
    {
        int sts = ulist_soc_add_one(&pool->read_sockets, socket_ctx);
        if (sts != 0)
        {
            return TCS_ERROR_MEMORY;
        }
    }
    if (poll_can_write)
    {
        int sts = ulist_soc_add_one(&pool->write_sockets, socket_ctx);
        if (sts != 0)
        {
            ulist_soc_pop(&pool->read_sockets, NULL);
            return TCS_ERROR_MEMORY;
        }
    }
    if (poll_error)
    {
        int sts = ulist_soc_add_one(&pool->error_sockets, socket_ctx);
        if (sts != 0)
        {
            ulist_soc_pop(&pool->read_sockets, NULL);
            ulist_soc_pop(&pool->write_sockets, NULL);
            return TCS_ERROR_MEMORY;
        }
    }
    return TCS_SUCCESS;
}

TcsReturnCode tcs_pool_remove(struct TcsPool* pool, TcsSocket socket_ctx)
{
    for (size_t i = 0; i < pool->read_sockets.count; ++i)
    {
        if (pool->read_sockets.data[i] == socket_ctx)
        {
            ulist_soc_remove_one(&pool->read_sockets, i);
            break;
        }
    }
    for (size_t i = 0; i < pool->write_sockets.count; ++i)
    {
        if (pool->write_sockets.data[i] == socket_ctx)
        {
            ulist_soc_remove_one(&pool->write_sockets, i);
            break;
        }
    }
    for (size_t i = 0; i < pool->error_sockets.count; ++i)
    {
        if (pool->error_sockets.data[i] == socket_ctx)
        {
            ulist_soc_remove_one(&pool->error_sockets, i);
            break;
        }
    }
    for (size_t i = 0; i < pool->user_data.count; ++i)
    {
        if (pool->user_data.key[i] == socket_ctx)
        {
            pool->user_data.count--;
            pool->user_data.key[i] = pool->user_data.key[pool->user_data.count];
            pool->user_data.value[i] = pool->user_data.value[pool->user_data.count];
        }
    }

    return TCS_SUCCESS;
}

TcsReturnCode tcs_pool_poll(struct TcsPool* pool,
                            struct TcsPollEvent* events,
                            size_t events_capacity,
                            size_t* events_populated,
                            int64_t timeout_in_ms)
{
    if (pool == NULL)
        return TCS_ERROR_INVALID_ARGUMENT;
    if (timeout_in_ms != TCS_INF && (timeout_in_ms > 0xffffffff || timeout_in_ms < 0))
        return TCS_ERROR_INVALID_ARGUMENT;

    // Copy fds
    //
    // Allocate so that we can access fd_array out of nominel bounds
    // We need this hack to be able to use dynamic memory for select
    const size_t data_offset = offsetof(struct tcs_fd_set, fd_array);

    struct tcs_fd_set* rfds_cpy = (struct tcs_fd_set*)malloc(data_offset + sizeof(SOCKET) * pool->read_sockets.count);
    struct tcs_fd_set* wfds_cpy = (struct tcs_fd_set*)malloc(data_offset + sizeof(SOCKET) * pool->write_sockets.count);
    struct tcs_fd_set* efds_cpy = (struct tcs_fd_set*)malloc(data_offset + sizeof(SOCKET) * pool->error_sockets.count);
    if (rfds_cpy == NULL || wfds_cpy == NULL || efds_cpy == NULL)
    {
        free(rfds_cpy);
        free(wfds_cpy);
        free(efds_cpy);

        return TCS_ERROR_MEMORY;
    }
    rfds_cpy->fd_count = (u_int)pool->read_sockets.count;
    wfds_cpy->fd_count = (u_int)pool->write_sockets.count;
    efds_cpy->fd_count = (u_int)pool->error_sockets.count;

    memcpy(rfds_cpy->fd_array, pool->read_sockets.data, sizeof(SOCKET) * pool->read_sockets.count);
    memcpy(wfds_cpy->fd_array, pool->write_sockets.data, sizeof(SOCKET) * pool->write_sockets.count);
    memcpy(efds_cpy->fd_array, pool->error_sockets.data, sizeof(SOCKET) * pool->error_sockets.count);

    // Run select
    struct timeval* t_ptr = NULL;
    struct timeval t = {0, 0};
    if (timeout_in_ms != TCS_INF)
    {
        t.tv_sec = (long)(timeout_in_ms / 1000);
        t.tv_usec = (long)(timeout_in_ms % 1000) * 1000;
        t_ptr = &t;
    }
    int no = select(IGNORE, (fd_set*)rfds_cpy, (fd_set*)wfds_cpy, (fd_set*)efds_cpy, t_ptr);

    size_t events_added = 0;

    if (no > 0)
    {
        memset(events, 0, sizeof(struct TcsPollEvent) * min((size_t)no, events_capacity));
        for (u_int n = 0; n < rfds_cpy->fd_count && events_added < events_capacity; ++n)
        {
            events[events_added].socket = rfds_cpy->fd_array[n];
            events[events_added].can_read = true;
            for (size_t i = 0; i < pool->user_data.count; ++i)
            {
                if (events[events_added].socket == pool->user_data.key[i])
                {
                    events[events_added].user_data = pool->user_data.value[i];
                    pool->user_data.key[pool->user_data.count] = pool->user_data.key[i];
                    pool->user_data.value[pool->user_data.count] = pool->user_data.value[i];
                    pool->user_data.count--;
                    break;
                }
            }
            events_added++;
        }
        for (u_int n = 0; n < wfds_cpy->fd_count && events_added < events_capacity; ++n)
        {
            // Check already added events
            size_t new_n = events_added;
            for (size_t m = 0; m < events_added; ++m)
            {
                if (events[m].socket == wfds_cpy->fd_array[n])
                {
                    new_n = m;
                    break;
                }
            }
            events[new_n].can_write = true;
            // Check for new events
            if (events_added == new_n)
            {
                events[new_n].socket = wfds_cpy->fd_array[n];

                for (size_t i = 0; i < pool->user_data.count; ++i)
                {
                    if (events[new_n].socket == pool->user_data.key[i])
                    {
                        events[new_n].user_data = pool->user_data.value[i];
                        pool->user_data.key[pool->user_data.count] = pool->user_data.key[i];
                        pool->user_data.value[pool->user_data.count] = pool->user_data.value[i];
                        pool->user_data.count--;
                        break;
                    }
                }
                events_added++;
            }
        }
        for (u_int n = 0; n < efds_cpy->fd_count && events_added < events_capacity; ++n)
        {
            // Check already added events
            size_t new_n = events_added;
            for (size_t m = 0; m < events_added; ++m)
            {
                if (events[m].socket == efds_cpy->fd_array[n])
                {
                    new_n = m;
                    break;
                }
            }
            // Check for new events
            events[new_n].error = TCS_ERROR_NOT_IMPLEMENTED; //TODO(markusl): This does not feel right
            if (events_added == new_n)
            {
                events[new_n].socket = efds_cpy->fd_array[n];

                for (size_t i = 0; i < pool->user_data.count; ++i)
                {
                    if (events[new_n].socket == pool->user_data.key[i])
                    {
                        events[new_n].user_data = pool->user_data.value[i];
                        pool->user_data.key[pool->user_data.count] = pool->user_data.key[i];
                        pool->user_data.value[pool->user_data.count] = pool->user_data.value[i];
                        pool->user_data.count--;
                        break;
                    }
                }

                events_added++;
            }
        }
        bool is_minimum = pool->user_data.capacity_bytes == TCS_POOL_CAPACITY_STEP;
        bool should_shrink =
            pool->user_data.capacity_bytes >= pool->user_data.count + 2 * TCS_POOL_CAPACITY_STEP; // hysteresis
        if (!is_minimum && should_shrink)
        {
            size_t new_capacity = pool->user_data.capacity_bytes - 2 * TCS_POOL_CAPACITY_STEP;
            TcsSocket* new_key = (TcsSocket*)realloc(pool->user_data.key, new_capacity);
            if (new_key == NULL)
                return TCS_ERROR_MEMORY; // Should not happen since we are shrinking

            pool->user_data.key = new_key;

            void** new_value = (void**)realloc(pool->user_data.value, new_capacity);
            if (new_value == NULL)
            {
                new_key = (TcsSocket*)realloc(pool->user_data.key, pool->user_data.capacity_bytes);
                if (new_key != NULL) // Should not happen since we are shrinking
                    pool->user_data.key = new_key;
                return TCS_ERROR_MEMORY;
            }

            pool->user_data.capacity_bytes = new_capacity;
            pool->user_data.value = new_value;
            pool->user_data.key = new_key;
        }
    }

    if (events_populated != NULL)
        *events_populated = events_added;

    // Clean up
    free(rfds_cpy);
    free(wfds_cpy);
    free(efds_cpy);

    if (no == 0)
    {
        return TCS_ERROR_TIMED_OUT;
    }
    if (no == SOCKET_ERROR)
    {
        int error_code = WSAGetLastError();
        return wsaerror2retcode(error_code);
    }

    return TCS_SUCCESS;
}

TcsReturnCode tcs_set_option(TcsSocket socket_ctx,
                             int32_t level,
                             int32_t option_name,
                             const void* option_value,
                             size_t option_size)
{
    if (socket_ctx == TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;

    int sockopt_status =
        setsockopt(socket_ctx, (int)level, (int)option_name, (const char*)option_value, (int)option_size);
    return socketstatus2retcode(sockopt_status);
}

TcsReturnCode tcs_get_option(TcsSocket socket_ctx,
                             int32_t level,
                             int32_t option_name,
                             void* option_value,
                             size_t* option_size)
{
    if (socket_ctx == TCS_NULLSOCKET || option_value == NULL || option_size == NULL)
        return TCS_ERROR_INVALID_ARGUMENT;

    int sockopt_status = getsockopt(socket_ctx, (int)level, (int)option_name, (char*)option_value, (int*)option_size);
    return socketstatus2retcode(sockopt_status);
}

TcsReturnCode tcs_shutdown(TcsSocket socket_ctx, TcsSocketDirection direction)
{
    const int LUT[] = {SD_RECEIVE, SD_SEND, SD_BOTH};

    if (socket_ctx == TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;

    const int how = LUT[direction];
    int shutdown_status = shutdown(socket_ctx, how);
    return socketstatus2retcode(shutdown_status);
}

TcsReturnCode tcs_destroy(TcsSocket* socket_ctx)
{
    if (socket_ctx == NULL || *socket_ctx == TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;

    int close_status = closesocket(*socket_ctx);
    if (close_status != SOCKET_ERROR)
    {
        *socket_ctx = TCS_NULLSOCKET;
        return TCS_SUCCESS;
    }
    else
    {
        return socketstatus2retcode(close_status);
    }
}

TcsReturnCode tcs_resolve_hostname(const char* hostname,
                                   TcsAddressFamily address_family,
                                   struct TcsAddress found_addresses[],
                                   size_t found_addresses_length,
                                   size_t* no_of_found_addresses)
{
    if (hostname == NULL)
        return TCS_ERROR_INVALID_ARGUMENT;

    if (found_addresses == NULL && no_of_found_addresses == NULL)
        return TCS_ERROR_INVALID_ARGUMENT;

    if (no_of_found_addresses != NULL)
        *no_of_found_addresses = 0;

    ADDRINFOA native_hints;
    memset(&native_hints, 0, sizeof native_hints);
    TcsReturnCode sts = family2native(address_family, (short*)&native_hints.ai_family);
    if (sts != TCS_SUCCESS)
        return sts;

    PADDRINFOA native_addrinfo_list = NULL;
    int getaddrinfo_status = getaddrinfo(hostname, NULL, &native_hints, &native_addrinfo_list);
    if (getaddrinfo_status != 0)
        return TCS_ERROR_ADDRESS_LOOKUP_FAILED;

    if (native_addrinfo_list == NULL)
        return TCS_ERROR_UNKNOWN;

    size_t i = 0;
    if (found_addresses == NULL)
    {
        for (PADDRINFOA iter = native_addrinfo_list; iter != NULL; iter = iter->ai_next)
            i++;
    }
    else
    {
        for (PADDRINFOA iter = native_addrinfo_list; iter != NULL && i < found_addresses_length; iter = iter->ai_next)
        {
            TcsReturnCode address_convert_status = native2sockaddr(iter->ai_addr, &found_addresses[i]);
            if (address_convert_status != TCS_SUCCESS)
                continue;
            i++;
        }
    }
    if (no_of_found_addresses != NULL)
        *no_of_found_addresses = i;

    freeaddrinfo(native_addrinfo_list);

    if (i == 0)
        return TCS_ERROR_ADDRESS_LOOKUP_FAILED;

    return TCS_SUCCESS;
}

TcsReturnCode tcs_local_interfaces(struct TcsInterface found_interfaces[],
                                   size_t found_interfaces_length,
                                   size_t* no_of_found_interfaces)
{
    if (found_interfaces == NULL && no_of_found_interfaces == NULL)
        return TCS_ERROR_INVALID_ARGUMENT;

    if (found_interfaces == NULL && found_interfaces_length != 0)
        return TCS_ERROR_INVALID_ARGUMENT;

    if (no_of_found_interfaces != NULL)
        *no_of_found_interfaces = 0;

    const int MAX_TRIES = 3;
    ULONG adapeters_buffer_size = 15000;
    PIP_ADAPTER_ADDRESSES adapters = NULL;
    ULONG adapter_sts = ERROR_NO_DATA;
    for (int i = 0; i < MAX_TRIES; ++i)
    {
        adapters = (PIP_ADAPTER_ADDRESSES)malloc(adapeters_buffer_size);
        adapter_sts = GetAdaptersAddresses(AF_UNSPEC, 0, NULL, adapters, &adapeters_buffer_size);
        if (adapter_sts == ERROR_BUFFER_OVERFLOW)
        {
            free(adapters);
            adapters = NULL;
        }
        else
        {
            break;
        }
    }
    if (adapter_sts != NO_ERROR)
    {
        if (adapters != NULL)
            free(adapters);
        return TCS_ERROR_UNKNOWN;
    }

    size_t i = 0;
    for (PIP_ADAPTER_ADDRESSES iter = adapters;
         iter != NULL && (found_interfaces == NULL || i < found_interfaces_length);
         iter = iter->Next)
    {
        if (iter->OperStatus != IfOperStatusUp)
            continue;
        for (PIP_ADAPTER_UNICAST_ADDRESS address_iter = iter->FirstUnicastAddress; address_iter != NULL;
             address_iter = address_iter->Next)
        {
            struct TcsAddress t;
            if (native2sockaddr(address_iter->Address.lpSockaddr, &t) != TCS_SUCCESS)
                continue;
            if (found_interfaces != NULL)
            {
                found_interfaces[i].address = t;
                memset(found_interfaces[i].name, '\0', 32);
                WideCharToMultiByte(CP_UTF8, 0, iter->FriendlyName, -1, found_interfaces[i].name, 31, NULL, NULL);
            }
            ++i;
        }
    }
    if (adapters != NULL)
        free(adapters);
    if (no_of_found_interfaces != NULL)
        *no_of_found_interfaces = i;

    return TCS_SUCCESS;
}

TcsReturnCode tcs_set_linger(TcsSocket socket_ctx, bool do_linger, int timeout_seconds)
{
    if (socket_ctx == TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;

    struct linger l = {(u_short)do_linger, (u_short)timeout_seconds};
    return tcs_set_option(socket_ctx, TCS_SOL_SOCKET, TCS_SO_LINGER, &l, sizeof(l));
}

TcsReturnCode tcs_get_linger(TcsSocket socket_ctx, bool* do_linger, int* timeout_seconds)
{
    if (socket_ctx == TCS_NULLSOCKET || (do_linger == NULL && timeout_seconds == NULL))
        return TCS_ERROR_INVALID_ARGUMENT;

    struct linger l = {0, 0};
    size_t l_size = sizeof(l);
    TcsReturnCode sts = tcs_get_option(socket_ctx, TCS_SOL_SOCKET, TCS_SO_LINGER, &l, &l_size);
    if (sts == TCS_SUCCESS)
    {
        if (do_linger)
            *do_linger = l.l_onoff;
        if (timeout_seconds)
            *timeout_seconds = l.l_linger;
    }

    return sts;
}

TcsReturnCode tcs_set_receive_timeout(TcsSocket socket_ctx, int timeout_ms)
{
    if (socket_ctx == TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;

    return tcs_set_option(socket_ctx, TCS_SOL_SOCKET, TCS_SO_RCVTIMEO, &timeout_ms, sizeof(timeout_ms));
}

TcsReturnCode tcs_get_receive_timeout(TcsSocket socket_ctx, int* timeout_ms)
{
    if (socket_ctx == TCS_NULLSOCKET || timeout_ms == NULL)
        return TCS_ERROR_INVALID_ARGUMENT;

    DWORD t = 0;
    size_t t_size = sizeof(t);
    TcsReturnCode sts = tcs_get_option(socket_ctx, TCS_SOL_SOCKET, TCS_SO_RCVTIMEO, &t, &t_size);

    if (sts == TCS_SUCCESS)
    {
        *timeout_ms = (int)t;
    }
    return sts;
}

TcsReturnCode tcs_set_ip_multicast_add(TcsSocket socket_ctx,
                                       const struct TcsAddress* local_address,
                                       const struct TcsAddress* multicast_address)
{
    if (multicast_address == NULL)
        return TCS_ERROR_INVALID_ARGUMENT;

    // TODO(markusl): Add ipv6 support
    if (multicast_address->family != TCS_AF_IP4)
        return TCS_ERROR_NOT_IMPLEMENTED;

    struct ip_mreq imr;
    memset(&imr, 0, sizeof imr);
    imr.imr_multiaddr.s_addr = htonl(multicast_address->data.af_inet.address);
    if (local_address != NULL)
        imr.imr_interface.s_addr = htonl(local_address->data.af_inet.address);

    return tcs_set_option(socket_ctx, TCS_SOL_IP, TCS_SO_IP_MEMBERSHIP_ADD, &imr, sizeof(imr));
}

TcsReturnCode tcs_set_ip_multicast_drop(TcsSocket socket_ctx,
                                        const struct TcsAddress* local_address,
                                        const struct TcsAddress* multicast_address)
{
    if (multicast_address == NULL)
        return TCS_ERROR_INVALID_ARGUMENT;

    // TODO(markusl): Add ipv6 support
    if (multicast_address->family != TCS_AF_IP4)
        return TCS_ERROR_NOT_IMPLEMENTED;

    struct ip_mreq imr;
    memset(&imr, 0, sizeof imr);
    imr.imr_multiaddr.s_addr = htonl(multicast_address->data.af_inet.address);
    if (local_address != NULL)
        imr.imr_interface.s_addr = htonl(local_address->data.af_inet.address);

    return tcs_set_option(socket_ctx, TCS_SOL_IP, TCS_SO_IP_MEMBERSHIP_DROP, &imr, sizeof(imr));
}
#endif

/**********************************/
/****** tinycsocket_common.h ******/
/**********************************/
/*
 * Copyright 2018 Markus Lindelöw
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files(the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
#ifndef TINYCSOCKET_INTERNAL_H_
#include "tinycsocket_internal.h"
#endif

// This file should never call OS dependent code. Do not include OS files of OS specific ifdefs

#ifdef DO_WRAP
#include "dbg_wrap.h"
#endif

#include <stdbool.h>
#include <stdio.h>  //sprintf
#include <string.h> // memset

TcsReturnCode tcs_util_ipv4_args(uint8_t a, uint8_t b, uint8_t c, uint8_t d, uint32_t* out_address)
{
    if (out_address == NULL)
        return TCS_ERROR_INVALID_ARGUMENT;

    *out_address = (uint32_t)a << 24 | (uint32_t)b << 16 | (uint32_t)c << 8 | d;
    return TCS_SUCCESS;
}

TcsReturnCode tcs_util_string_to_address(const char str[], struct TcsAddress* parsed_address)
{
    if (parsed_address == NULL)
        return TCS_ERROR_INVALID_ARGUMENT;

    memset(parsed_address, 0, sizeof(struct TcsAddress));
    // Slow but easy parser
    int n_colons = 0;
    int n_dots = 0;

    for (int i = 0; i < 21; ++i) // max ipv4 string length with port colon
    {
        if (str[i] == '.')
            n_dots++;
        else if (str[i] == ':')
            n_colons++;
    }
    bool is_ipv4 = n_dots > 0;
    //bool is_ipv6 = n_colons > 1;

    if (is_ipv4)
    {
        int b1;
        int b2;
        int b3;
        int b4;
        int p = 0;

        int parsed_args = sscanf(str, "%i.%i.%i.%i:%i", &b1, &b2, &b3, &b4, &p);
        if (parsed_args != 4 && parsed_args != 5)
            return TCS_ERROR_INVALID_ARGUMENT;

        if ((uint8_t)(b1 & 0xFF) != b1 || (uint8_t)(b2 & 0xFF) != b2 || (uint8_t)(b3 & 0xFF) != b3 ||
            (uint8_t)(b4 & 0xFF) != b4)
            return TCS_ERROR_INVALID_ARGUMENT;
        if (p < 0 || p > 65535)
            return TCS_ERROR_INVALID_ARGUMENT;

        parsed_address->family = TCS_AF_IP4;
        if (tcs_util_ipv4_args(
                (uint8_t)b1, (uint8_t)b2, (uint8_t)b3, (uint8_t)b4, &parsed_address->data.af_inet.address) !=
            TCS_SUCCESS)
            return TCS_ERROR_UNKNOWN;
        parsed_address->data.af_inet.port = (uint16_t)p;
    }
    else
        return TCS_ERROR_NOT_IMPLEMENTED;

    return TCS_SUCCESS;
}

TcsReturnCode tcs_util_address_to_string(const struct TcsAddress* address, char str[40])
{
    if (str == NULL)
        return TCS_ERROR_INVALID_ARGUMENT;

    memset(str, 0, 40);
    if (address->family == TCS_AF_IP4)
    {
        uint32_t d = address->data.af_inet.address;
        uint16_t p = address->data.af_inet.port;
        uint8_t b1 = (uint8_t)(d & 0xFF);
        uint8_t b2 = (uint8_t)((d >> 8) & 0xFF);
        uint8_t b3 = (uint8_t)((d >> 16) & 0xFF);
        uint8_t b4 = (uint8_t)((d >> 24) & 0xFF);
        if (p == 0)
            sprintf(str, "%i.%i.%i.%i", b4, b3, b2, b1);
        else
            sprintf(str, "%i.%i.%i.%i:%i", b4, b3, b2, b1, p);
    }
    else
        return TCS_ERROR_NOT_IMPLEMENTED;

    return TCS_SUCCESS;
}

TcsReturnCode tcs_create(TcsSocket* socket_ctx, TcsType socket_type)
{
    if (socket_ctx == NULL || *socket_ctx != TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;

    TcsAddressFamily family = TCS_AF_ANY;
    int type = 0;
    int protocol = 0;

    switch (socket_type)
    {
        case TCS_TYPE_TCP_IP4:
            family = TCS_AF_IP4;
            type = TCS_SOCK_STREAM;
            protocol = TCS_IPPROTO_TCP;
            break;
        case TCS_TYPE_UDP_IP4:
            family = TCS_AF_IP4;
            type = TCS_SOCK_DGRAM;
            protocol = TCS_IPPROTO_UDP;
            break;
        case TCS_TYPE_TCP_IP6:
        case TCS_TYPE_UDP_IP6:
        default:
            return TCS_ERROR_NOT_IMPLEMENTED;
            break;
    }
    return tcs_create_ext(socket_ctx, family, type, protocol);
}

TcsReturnCode tcs_connect(TcsSocket socket_ctx, const char* hostname, uint16_t port)
{
    if (socket_ctx == TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;

    struct TcsAddress found_addresses[32];
    memset(found_addresses, 0, sizeof found_addresses);
    size_t no_of_found_addresses = 0;
    TcsAddressFamily family = TCS_AF_IP4;
    TcsReturnCode sts = tcs_resolve_hostname(hostname, family, found_addresses, 32, &no_of_found_addresses);
    if (sts != TCS_SUCCESS)
        return sts;

    for (size_t i = 0; i < no_of_found_addresses; ++i)
    {
        found_addresses[i].data.af_inet.port = port;
        if (tcs_connect_address(socket_ctx, &found_addresses[i]) == TCS_SUCCESS)
            return TCS_SUCCESS;
    }

    return TCS_ERROR_CONNECTION_REFUSED;
}

TcsReturnCode tcs_bind(TcsSocket socket_ctx, uint16_t port)
{
    if (socket_ctx == TCS_NULLSOCKET || port == 0)
        return TCS_ERROR_INVALID_ARGUMENT;

    struct TcsAddress local_address = TCS_ADDRESS_NULL;
    local_address.family = TCS_AF_IP4;
    local_address.data.af_inet.address = TCS_ADDRESS_ANY_IP4;
    local_address.data.af_inet.port = port;

    return tcs_bind_address(socket_ctx, &local_address);
}

TcsReturnCode tcs_listen_to(TcsSocket socket_ctx, uint16_t local_port)
{
    if (socket_ctx == TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;

    TcsReturnCode sts = tcs_bind(socket_ctx, local_port);
    if (sts != TCS_SUCCESS)
        return sts;

    return tcs_listen(socket_ctx, TCS_BACKLOG_SOMAXCONN);
}

TcsReturnCode tcs_receive_netstring(TcsSocket socket_ctx, uint8_t* buffer, size_t buffer_length, size_t* bytes_received)
{
    if (socket_ctx == TCS_NULLSOCKET || buffer == NULL || buffer_length <= 0)
        return TCS_ERROR_INVALID_ARGUMENT;

    size_t expected_length = 0;
    int parsed = 0;
    TcsReturnCode sts = TCS_SUCCESS;
    char t = '\0';
    const int max_header = 21;
    while (t != ':' && parsed < max_header)
    {
        sts = tcs_receive(socket_ctx, (uint8_t*)&t, 1, TCS_MSG_WAITALL, NULL);
        if (sts != TCS_SUCCESS)
            return sts;

        parsed += 1;

        bool is_num = t >= '0' && t <= '9';
        bool is_end = t == ':';
        if (!is_num && !is_end)
            return TCS_ERROR_ILL_FORMED_MESSAGE;

        if (is_end)
            break;

        expected_length += (size_t)t - '0';
    }

    if (parsed >= max_header)
        return TCS_ERROR_ILL_FORMED_MESSAGE;

    if (buffer_length < expected_length)
        return TCS_ERROR_MEMORY;

    sts = tcs_receive(socket_ctx, buffer, expected_length, TCS_MSG_WAITALL, NULL);
    if (sts != TCS_SUCCESS)
        return sts;

    sts = tcs_receive(socket_ctx, (uint8_t*)&t, 1, TCS_MSG_WAITALL, NULL);
    if (sts != TCS_SUCCESS)
        return sts;

    if (t != ',')
        return TCS_ERROR_ILL_FORMED_MESSAGE;

    if (bytes_received != NULL)
        *bytes_received = expected_length;

    return TCS_SUCCESS;
}

TcsReturnCode tcs_send_netstring(TcsSocket socket_ctx, const uint8_t* buffer, size_t buffer_length)
{
    if (socket_ctx == TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;

    if (buffer == NULL || buffer_length == 0)
        return TCS_ERROR_INVALID_ARGUMENT;

#if SIZE_MAX > 0xffffffffffffffffULL
    // buffer_length bigger than 64 bits? (size_t can be bigger on some systems)
    if (buffer_length > 0xffffffffffffffffULL)
        return TCS_ERROR_INVALID_ARGUMENT;
#endif

    int header_length = 0;
    char netstring_header[21];
    memset(netstring_header, 0, sizeof netstring_header);

    // %zu is not supported by all compilers, therefor we cast it to llu
    header_length = snprintf(netstring_header, 21, "%llu:", (unsigned long long)buffer_length);

    if (header_length < 0)
        return TCS_ERROR_INVALID_ARGUMENT;

    TcsReturnCode sts = TCS_SUCCESS;
    sts = tcs_send(socket_ctx, (uint8_t*)netstring_header, (size_t)header_length, TCS_MSG_SENDALL, NULL);
    if (sts != TCS_SUCCESS)
        return sts;

    sts = tcs_send(socket_ctx, buffer, buffer_length, TCS_MSG_SENDALL, NULL);
    if (sts != TCS_SUCCESS)
        return sts;

    sts = tcs_send(socket_ctx, (uint8_t*)",", 1, TCS_MSG_SENDALL, NULL);
    if (sts != TCS_SUCCESS)
        return sts;

    return TCS_SUCCESS;
}

TcsReturnCode tcs_set_broadcast(TcsSocket socket_ctx, bool do_allow_broadcast)
{
    if (socket_ctx == TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;

    int b = do_allow_broadcast ? 1 : 0;
    return tcs_set_option(socket_ctx, TCS_SOL_SOCKET, TCS_SO_BROADCAST, &b, sizeof(b));
}

TcsReturnCode tcs_get_broadcast(TcsSocket socket_ctx, bool* is_broadcast_allowed)
{
    if (socket_ctx == TCS_NULLSOCKET || is_broadcast_allowed == NULL)
        return TCS_ERROR_INVALID_ARGUMENT;
    int b = 0;
    size_t s = sizeof(b);
    TcsReturnCode sts = tcs_get_option(socket_ctx, TCS_SOL_SOCKET, TCS_SO_BROADCAST, &b, &s);
    *is_broadcast_allowed = b;
    return sts;
}

TcsReturnCode tcs_set_keep_alive(TcsSocket socket_ctx, bool do_keep_alive)
{
    if (socket_ctx == TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;

    int b = do_keep_alive ? 1 : 0;
    return tcs_set_option(socket_ctx, TCS_SOL_SOCKET, TCS_SO_KEEPALIVE, &b, sizeof(b));
}

TcsReturnCode tcs_get_keep_alive(TcsSocket socket_ctx, bool* is_keep_alive_enabled)
{
    if (socket_ctx == TCS_NULLSOCKET || is_keep_alive_enabled == NULL)
        return TCS_ERROR_INVALID_ARGUMENT;
    int b = 0;
    size_t s = sizeof(b);
    TcsReturnCode sts = tcs_get_option(socket_ctx, TCS_SOL_SOCKET, TCS_SO_KEEPALIVE, &b, &s);
    *is_keep_alive_enabled = b;
    return sts;
}

TcsReturnCode tcs_set_reuse_address(TcsSocket socket_ctx, bool do_allow_reuse_address)
{
    if (socket_ctx == TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;

    int b = do_allow_reuse_address ? 1 : 0;
    return tcs_set_option(socket_ctx, TCS_SOL_SOCKET, TCS_SO_REUSEADDR, &b, sizeof(b));
}

TcsReturnCode tcs_get_reuse_address(TcsSocket socket_ctx, bool* is_reuse_address_allowed)
{
    if (socket_ctx == TCS_NULLSOCKET || is_reuse_address_allowed == NULL)
        return TCS_ERROR_INVALID_ARGUMENT;
    int b = 0;
    size_t s = sizeof(b);
    TcsReturnCode sts = tcs_get_option(socket_ctx, TCS_SOL_SOCKET, TCS_SO_REUSEADDR, &b, &s);
    *is_reuse_address_allowed = b;
    return sts;
}

TcsReturnCode tcs_set_send_buffer_size(TcsSocket socket_ctx, size_t send_buffer_size)
{
    if (socket_ctx == TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;

    unsigned int b = (unsigned int)send_buffer_size;
    return tcs_set_option(socket_ctx, TCS_SOL_SOCKET, TCS_SO_SNDBUF, &b, sizeof(b));
}

TcsReturnCode tcs_get_send_buffer_size(TcsSocket socket_ctx, size_t* send_buffer_size)
{
    if (socket_ctx == TCS_NULLSOCKET || send_buffer_size == NULL)
        return TCS_ERROR_INVALID_ARGUMENT;
    unsigned int b = 0;
    size_t s = sizeof(b);
    TcsReturnCode sts = tcs_get_option(socket_ctx, TCS_SOL_SOCKET, TCS_SO_SNDBUF, &b, &s);
    *send_buffer_size = (size_t)b;
    return sts;
}

TcsReturnCode tcs_set_receive_buffer_size(TcsSocket socket_ctx, size_t receive_buffer_size)
{
    if (socket_ctx == TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;

    unsigned int b = (unsigned int)receive_buffer_size;
    return tcs_set_option(socket_ctx, TCS_SOL_SOCKET, TCS_SO_RCVBUF, &b, sizeof(b));
}

TcsReturnCode tcs_get_receive_buffer_size(TcsSocket socket_ctx, size_t* receive_buffer_size)
{
    if (socket_ctx == TCS_NULLSOCKET || receive_buffer_size == NULL)
        return TCS_ERROR_INVALID_ARGUMENT;
    unsigned int b = 0;
    size_t s = sizeof(b);
    TcsReturnCode sts = tcs_get_option(socket_ctx, TCS_SOL_SOCKET, TCS_SO_RCVBUF, &b, &s);
    *receive_buffer_size = (size_t)b;
    return sts;
}

TcsReturnCode tcs_set_ip_no_delay(TcsSocket socket_ctx, bool use_no_delay)
{
    if (socket_ctx == TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;

    int b = use_no_delay ? 1 : 0;
    return tcs_set_option(socket_ctx, TCS_SOL_IP, TCS_SO_IP_NODELAY, &b, sizeof(b));
}

TcsReturnCode tcs_get_ip_no_delay(TcsSocket socket_ctx, bool* is_no_delay_used)
{
    if (socket_ctx == TCS_NULLSOCKET || is_no_delay_used == NULL)
        return TCS_ERROR_INVALID_ARGUMENT;
    int b = 0;
    size_t s = sizeof(b);
    TcsReturnCode sts = tcs_get_option(socket_ctx, TCS_SOL_IP, TCS_SO_IP_NODELAY, &b, &s);
    *is_no_delay_used = b;
    return sts;
}

TcsReturnCode tcs_set_out_of_band_inline(TcsSocket socket_ctx, bool enable_oob)
{
    if (socket_ctx == TCS_NULLSOCKET)
        return TCS_ERROR_INVALID_ARGUMENT;

    int b = enable_oob ? 1 : 0;
    return tcs_set_option(socket_ctx, TCS_SOL_SOCKET, TCS_SO_OOBINLINE, &b, sizeof(b));
}

TcsReturnCode tcs_get_out_of_band_inline(TcsSocket socket_ctx, bool* is_oob_enabled)
{
    if (socket_ctx == TCS_NULLSOCKET || is_oob_enabled == NULL)
        return TCS_ERROR_INVALID_ARGUMENT;
    int b = 0;
    size_t s = sizeof(b);
    TcsReturnCode sts = tcs_get_option(socket_ctx, TCS_SOL_SOCKET, TCS_SO_OOBINLINE, &b, &s);
    *is_oob_enabled = b;
    return sts;
}

#endif
#endif
